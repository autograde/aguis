// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ag.proto

package ag

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Group_GroupStatus int32

const (
	Group_PENDING  Group_GroupStatus = 0
	Group_REJECTED Group_GroupStatus = 1
	Group_APPROVED Group_GroupStatus = 2
)

var Group_GroupStatus_name = map[int32]string{
	0: "PENDING",
	1: "REJECTED",
	2: "APPROVED",
}

var Group_GroupStatus_value = map[string]int32{
	"PENDING":  0,
	"REJECTED": 1,
	"APPROVED": 2,
}

func (x Group_GroupStatus) String() string {
	return proto.EnumName(Group_GroupStatus_name, int32(x))
}

func (Group_GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3, 0}
}

type Repository_Type int32

const (
	Repository_NONE        Repository_Type = 0
	Repository_COURSEINFO  Repository_Type = 1
	Repository_ASSIGNMENTS Repository_Type = 2
	Repository_TESTS       Repository_Type = 3
	Repository_SOLUTIONS   Repository_Type = 4
	Repository_USER        Repository_Type = 5
	Repository_GROUP       Repository_Type = 6
)

var Repository_Type_name = map[int32]string{
	0: "NONE",
	1: "COURSEINFO",
	2: "ASSIGNMENTS",
	3: "TESTS",
	4: "SOLUTIONS",
	5: "USER",
	6: "GROUP",
}

var Repository_Type_value = map[string]int32{
	"NONE":        0,
	"COURSEINFO":  1,
	"ASSIGNMENTS": 2,
	"TESTS":       3,
	"SOLUTIONS":   4,
	"USER":        5,
	"GROUP":       6,
}

func (x Repository_Type) String() string {
	return proto.EnumName(Repository_Type_name, int32(x))
}

func (Repository_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7, 0}
}

type Enrollment_UserStatus int32

const (
	Enrollment_NONE     Enrollment_UserStatus = 0
	Enrollment_PENDING  Enrollment_UserStatus = 1
	Enrollment_REJECTED Enrollment_UserStatus = 2
	Enrollment_STUDENT  Enrollment_UserStatus = 3
	Enrollment_TEACHER  Enrollment_UserStatus = 4
)

var Enrollment_UserStatus_name = map[int32]string{
	0: "NONE",
	1: "PENDING",
	2: "REJECTED",
	3: "STUDENT",
	4: "TEACHER",
}

var Enrollment_UserStatus_value = map[string]int32{
	"NONE":     0,
	"PENDING":  1,
	"REJECTED": 2,
	"STUDENT":  3,
	"TEACHER":  4,
}

func (x Enrollment_UserStatus) String() string {
	return proto.EnumName(Enrollment_UserStatus_name, int32(x))
}

func (Enrollment_UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{10, 0}
}

type User struct {
	ID                   uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	IsAdmin              bool              `protobuf:"varint,2,opt,name=isAdmin,proto3" json:"isAdmin,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	StudentID            string            `protobuf:"bytes,4,opt,name=studentID,proto3" json:"studentID,omitempty"`
	Email                string            `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	AvatarURL            string            `protobuf:"bytes,6,opt,name=avatarURL,proto3" json:"avatarURL,omitempty"`
	Login                string            `protobuf:"bytes,7,opt,name=login,proto3" json:"login,omitempty"`
	RemoteIdentities     []*RemoteIdentity `protobuf:"bytes,8,rep,name=remoteIdentities,proto3" json:"remoteIdentities,omitempty"`
	Enrollments          []*Enrollment     `protobuf:"bytes,9,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{0}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetStudentID() string {
	if m != nil {
		return m.StudentID
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetAvatarURL() string {
	if m != nil {
		return m.AvatarURL
	}
	return ""
}

func (m *User) GetLogin() string {
	if m != nil {
		return m.Login
	}
	return ""
}

func (m *User) GetRemoteIdentities() []*RemoteIdentity {
	if m != nil {
		return m.RemoteIdentities
	}
	return nil
}

func (m *User) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Users struct {
	Users                []*User  `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Users) Reset()         { *m = Users{} }
func (m *Users) String() string { return proto.CompactTextString(m) }
func (*Users) ProtoMessage()    {}
func (*Users) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{1}
}
func (m *Users) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Users) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Users.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Users) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Users.Merge(m, src)
}
func (m *Users) XXX_Size() int {
	return m.Size()
}
func (m *Users) XXX_DiscardUnknown() {
	xxx_messageInfo_Users.DiscardUnknown(m)
}

var xxx_messageInfo_Users proto.InternalMessageInfo

func (m *Users) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type RemoteIdentity struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Provider             string   `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	RemoteID             uint64   `protobuf:"varint,3,opt,name=remoteID,proto3" json:"remoteID,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	AccessToken          string   `protobuf:"bytes,4,opt,name=accessToken,proto3" json:"accessToken,omitempty"`
	UserID               uint64   `protobuf:"varint,5,opt,name=userID,proto3" json:"userID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteIdentity) Reset()         { *m = RemoteIdentity{} }
func (m *RemoteIdentity) String() string { return proto.CompactTextString(m) }
func (*RemoteIdentity) ProtoMessage()    {}
func (*RemoteIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{2}
}
func (m *RemoteIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteIdentity.Merge(m, src)
}
func (m *RemoteIdentity) XXX_Size() int {
	return m.Size()
}
func (m *RemoteIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteIdentity proto.InternalMessageInfo

func (m *RemoteIdentity) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoteIdentity) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *RemoteIdentity) GetRemoteID() uint64 {
	if m != nil {
		return m.RemoteID
	}
	return 0
}

func (m *RemoteIdentity) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *RemoteIdentity) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type Group struct {
	ID                   uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" gorm:"unique_index:idx_unique_group_name"`
	CourseID             uint64            `protobuf:"varint,3,opt,name=courseID,proto3" json:"courseID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	TeamID               uint64            `protobuf:"varint,4,opt,name=teamID,proto3" json:"teamID,omitempty"`
	Status               Group_GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=Group_GroupStatus" json:"status,omitempty"`
	Users                []*User           `protobuf:"bytes,6,rep,name=users,proto3" json:"users,omitempty"`
	Enrollments          []*Enrollment     `protobuf:"bytes,7,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Group) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Group) GetTeamID() uint64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *Group) GetStatus() Group_GroupStatus {
	if m != nil {
		return m.Status
	}
	return Group_PENDING
}

func (m *Group) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Group) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Groups struct {
	Groups               []*Group `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Groups) Reset()         { *m = Groups{} }
func (m *Groups) String() string { return proto.CompactTextString(m) }
func (*Groups) ProtoMessage()    {}
func (*Groups) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{4}
}
func (m *Groups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Groups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Groups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Groups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Groups.Merge(m, src)
}
func (m *Groups) XXX_Size() int {
	return m.Size()
}
func (m *Groups) XXX_DiscardUnknown() {
	xxx_messageInfo_Groups.DiscardUnknown(m)
}

var xxx_messageInfo_Groups proto.InternalMessageInfo

func (m *Groups) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Course struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseCreatorID      uint64                `protobuf:"varint,2,opt,name=courseCreatorID,proto3" json:"courseCreatorID,omitempty"`
	Name                 string                `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Code                 string                `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Year                 uint32                `protobuf:"varint,5,opt,name=year,proto3" json:"year,omitempty"`
	Tag                  string                `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
	Provider             string                `protobuf:"bytes,7,opt,name=provider,proto3" json:"provider,omitempty"`
	OrganizationID       uint64                `protobuf:"varint,8,opt,name=organizationID,proto3" json:"organizationID,omitempty"`
	Enrolled             Enrollment_UserStatus `protobuf:"varint,9,opt,name=enrolled,proto3,enum=Enrollment_UserStatus" json:"enrolled,omitempty" sql:"-"`
	Enrollments          []*Enrollment         `protobuf:"bytes,10,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	Assignments          []*Assignment         `protobuf:"bytes,12,rep,name=assignments,proto3" json:"assignments,omitempty"`
	Groups               []*Group              `protobuf:"bytes,13,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Course) Reset()         { *m = Course{} }
func (m *Course) String() string { return proto.CompactTextString(m) }
func (*Course) ProtoMessage()    {}
func (*Course) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{5}
}
func (m *Course) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Course) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Course.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Course) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Course.Merge(m, src)
}
func (m *Course) XXX_Size() int {
	return m.Size()
}
func (m *Course) XXX_DiscardUnknown() {
	xxx_messageInfo_Course.DiscardUnknown(m)
}

var xxx_messageInfo_Course proto.InternalMessageInfo

func (m *Course) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Course) GetCourseCreatorID() uint64 {
	if m != nil {
		return m.CourseCreatorID
	}
	return 0
}

func (m *Course) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Course) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Course) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *Course) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Course) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Course) GetOrganizationID() uint64 {
	if m != nil {
		return m.OrganizationID
	}
	return 0
}

func (m *Course) GetEnrolled() Enrollment_UserStatus {
	if m != nil {
		return m.Enrolled
	}
	return Enrollment_NONE
}

func (m *Course) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

func (m *Course) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

func (m *Course) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Courses struct {
	Courses              []*Course `protobuf:"bytes,1,rep,name=courses,proto3" json:"courses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Courses) Reset()         { *m = Courses{} }
func (m *Courses) String() string { return proto.CompactTextString(m) }
func (*Courses) ProtoMessage()    {}
func (*Courses) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{6}
}
func (m *Courses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Courses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Courses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Courses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Courses.Merge(m, src)
}
func (m *Courses) XXX_Size() int {
	return m.Size()
}
func (m *Courses) XXX_DiscardUnknown() {
	xxx_messageInfo_Courses.DiscardUnknown(m)
}

var xxx_messageInfo_Courses proto.InternalMessageInfo

func (m *Courses) GetCourses() []*Course {
	if m != nil {
		return m.Courses
	}
	return nil
}

type Repository struct {
	ID                   uint64          `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	OrganizationID       uint64          `protobuf:"varint,2,opt,name=organizationID,proto3" json:"organizationID,omitempty"`
	RepositoryID         uint64          `protobuf:"varint,3,opt,name=repositoryID,proto3" json:"repositoryID,omitempty"`
	UserID               uint64          `protobuf:"varint,4,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64          `protobuf:"varint,5,opt,name=groupID,proto3" json:"groupID,omitempty"`
	HTMLURL              string          `protobuf:"bytes,6,opt,name=HTMLURL,proto3" json:"HTMLURL,omitempty"`
	RepoType             Repository_Type `protobuf:"varint,7,opt,name=repoType,proto3,enum=Repository_Type" json:"repoType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Repository) Reset()         { *m = Repository{} }
func (m *Repository) String() string { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()    {}
func (*Repository) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7}
}
func (m *Repository) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repository.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repository.Merge(m, src)
}
func (m *Repository) XXX_Size() int {
	return m.Size()
}
func (m *Repository) XXX_DiscardUnknown() {
	xxx_messageInfo_Repository.DiscardUnknown(m)
}

var xxx_messageInfo_Repository proto.InternalMessageInfo

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetOrganizationID() uint64 {
	if m != nil {
		return m.OrganizationID
	}
	return 0
}

func (m *Repository) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Repository) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Repository) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Repository) GetHTMLURL() string {
	if m != nil {
		return m.HTMLURL
	}
	return ""
}

func (m *Repository) GetRepoType() Repository_Type {
	if m != nil {
		return m.RepoType
	}
	return Repository_NONE
}

type Organization struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Avatar               string   `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	PaymentPlan          string   `protobuf:"bytes,4,opt,name=paymentPlan,proto3" json:"paymentPlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Organization) Reset()         { *m = Organization{} }
func (m *Organization) String() string { return proto.CompactTextString(m) }
func (*Organization) ProtoMessage()    {}
func (*Organization) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{8}
}
func (m *Organization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Organization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Organization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Organization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Organization.Merge(m, src)
}
func (m *Organization) XXX_Size() int {
	return m.Size()
}
func (m *Organization) XXX_DiscardUnknown() {
	xxx_messageInfo_Organization.DiscardUnknown(m)
}

var xxx_messageInfo_Organization proto.InternalMessageInfo

func (m *Organization) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Organization) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Organization) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *Organization) GetPaymentPlan() string {
	if m != nil {
		return m.PaymentPlan
	}
	return ""
}

type Organizations struct {
	Organizations        []*Organization `protobuf:"bytes,1,rep,name=organizations,proto3" json:"organizations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Organizations) Reset()         { *m = Organizations{} }
func (m *Organizations) String() string { return proto.CompactTextString(m) }
func (*Organizations) ProtoMessage()    {}
func (*Organizations) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{9}
}
func (m *Organizations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Organizations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Organizations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Organizations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Organizations.Merge(m, src)
}
func (m *Organizations) XXX_Size() int {
	return m.Size()
}
func (m *Organizations) XXX_DiscardUnknown() {
	xxx_messageInfo_Organizations.DiscardUnknown(m)
}

var xxx_messageInfo_Organizations proto.InternalMessageInfo

func (m *Organizations) GetOrganizations() []*Organization {
	if m != nil {
		return m.Organizations
	}
	return nil
}

type Enrollment struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseID             uint64                `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty" gorm:"unique_index:idx_unique_enrollment"`
	UserID               uint64                `protobuf:"varint,3,opt,name=userID,proto3" json:"userID,omitempty" gorm:"unique_index:idx_unique_enrollment"`
	GroupID              uint64                `protobuf:"varint,4,opt,name=groupID,proto3" json:"groupID,omitempty"`
	User                 *User                 `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
	Course               *Course               `protobuf:"bytes,6,opt,name=course,proto3" json:"course,omitempty"`
	Group                *Group                `protobuf:"bytes,7,opt,name=group,proto3" json:"group,omitempty"`
	Status               Enrollment_UserStatus `protobuf:"varint,8,opt,name=status,proto3,enum=Enrollment_UserStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Enrollment) Reset()         { *m = Enrollment{} }
func (m *Enrollment) String() string { return proto.CompactTextString(m) }
func (*Enrollment) ProtoMessage()    {}
func (*Enrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{10}
}
func (m *Enrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollment.Merge(m, src)
}
func (m *Enrollment) XXX_Size() int {
	return m.Size()
}
func (m *Enrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollment.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollment proto.InternalMessageInfo

func (m *Enrollment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Enrollment) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Enrollment) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Enrollment) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Enrollment) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Enrollment) GetCourse() *Course {
	if m != nil {
		return m.Course
	}
	return nil
}

func (m *Enrollment) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Enrollment) GetStatus() Enrollment_UserStatus {
	if m != nil {
		return m.Status
	}
	return Enrollment_NONE
}

type Enrollments struct {
	Enrollments          []*Enrollment `protobuf:"bytes,1,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Enrollments) Reset()         { *m = Enrollments{} }
func (m *Enrollments) String() string { return proto.CompactTextString(m) }
func (*Enrollments) ProtoMessage()    {}
func (*Enrollments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{11}
}
func (m *Enrollments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollments.Merge(m, src)
}
func (m *Enrollments) XXX_Size() int {
	return m.Size()
}
func (m *Enrollments) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollments.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollments proto.InternalMessageInfo

func (m *Enrollments) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Assignment struct {
	ID                   uint64      `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseID             uint64      `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty"`
	Name                 string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Language             string      `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Deadline             string      `protobuf:"bytes,5,opt,name=deadline,proto3" json:"deadline,omitempty"`
	AutoApprove          bool        `protobuf:"varint,6,opt,name=autoApprove,proto3" json:"autoApprove,omitempty"`
	Order                uint32      `protobuf:"varint,7,opt,name=order,proto3" json:"order,omitempty"`
	IsGroupLab           bool        `protobuf:"varint,8,opt,name=isGroupLab,proto3" json:"isGroupLab,omitempty"`
	Submission           *Submission `protobuf:"bytes,9,opt,name=submission,proto3" json:"submission,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Assignment) Reset()         { *m = Assignment{} }
func (m *Assignment) String() string { return proto.CompactTextString(m) }
func (*Assignment) ProtoMessage()    {}
func (*Assignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{12}
}
func (m *Assignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignment.Merge(m, src)
}
func (m *Assignment) XXX_Size() int {
	return m.Size()
}
func (m *Assignment) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignment.DiscardUnknown(m)
}

var xxx_messageInfo_Assignment proto.InternalMessageInfo

func (m *Assignment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Assignment) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Assignment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Assignment) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Assignment) GetDeadline() string {
	if m != nil {
		return m.Deadline
	}
	return ""
}

func (m *Assignment) GetAutoApprove() bool {
	if m != nil {
		return m.AutoApprove
	}
	return false
}

func (m *Assignment) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *Assignment) GetIsGroupLab() bool {
	if m != nil {
		return m.IsGroupLab
	}
	return false
}

func (m *Assignment) GetSubmission() *Submission {
	if m != nil {
		return m.Submission
	}
	return nil
}

type Assignments struct {
	Assignments          []*Assignment `protobuf:"bytes,1,rep,name=assignments,proto3" json:"assignments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Assignments) Reset()         { *m = Assignments{} }
func (m *Assignments) String() string { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()    {}
func (*Assignments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{13}
}
func (m *Assignments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignments.Merge(m, src)
}
func (m *Assignments) XXX_Size() int {
	return m.Size()
}
func (m *Assignments) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignments.DiscardUnknown(m)
}

var xxx_messageInfo_Assignments proto.InternalMessageInfo

func (m *Assignments) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

type Submission struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	AssignmentID         uint64   `protobuf:"varint,2,opt,name=assignmentID,proto3" json:"assignmentID,omitempty"`
	UserID               uint64   `protobuf:"varint,3,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64   `protobuf:"varint,4,opt,name=groupID,proto3" json:"groupID,omitempty"`
	Score                uint32   `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
	ScoreObjects         string   `protobuf:"bytes,6,opt,name=scoreObjects,proto3" json:"scoreObjects,omitempty"`
	BuildInfo            string   `protobuf:"bytes,7,opt,name=buildInfo,proto3" json:"buildInfo,omitempty"`
	CommitHash           string   `protobuf:"bytes,8,opt,name=commitHash,proto3" json:"commitHash,omitempty"`
	Approved             bool     `protobuf:"varint,9,opt,name=approved,proto3" json:"approved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Submission) Reset()         { *m = Submission{} }
func (m *Submission) String() string { return proto.CompactTextString(m) }
func (*Submission) ProtoMessage()    {}
func (*Submission) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{14}
}
func (m *Submission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submission.Merge(m, src)
}
func (m *Submission) XXX_Size() int {
	return m.Size()
}
func (m *Submission) XXX_DiscardUnknown() {
	xxx_messageInfo_Submission.DiscardUnknown(m)
}

var xxx_messageInfo_Submission proto.InternalMessageInfo

func (m *Submission) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Submission) GetAssignmentID() uint64 {
	if m != nil {
		return m.AssignmentID
	}
	return 0
}

func (m *Submission) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Submission) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Submission) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Submission) GetScoreObjects() string {
	if m != nil {
		return m.ScoreObjects
	}
	return ""
}

func (m *Submission) GetBuildInfo() string {
	if m != nil {
		return m.BuildInfo
	}
	return ""
}

func (m *Submission) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Submission) GetApproved() bool {
	if m != nil {
		return m.Approved
	}
	return false
}

type Submissions struct {
	Submissions          []*Submission `protobuf:"bytes,1,rep,name=submissions,proto3" json:"submissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Submissions) Reset()         { *m = Submissions{} }
func (m *Submissions) String() string { return proto.CompactTextString(m) }
func (*Submissions) ProtoMessage()    {}
func (*Submissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{15}
}
func (m *Submissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submissions.Merge(m, src)
}
func (m *Submissions) XXX_Size() int {
	return m.Size()
}
func (m *Submissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Submissions.DiscardUnknown(m)
}

var xxx_messageInfo_Submissions proto.InternalMessageInfo

func (m *Submissions) GetSubmissions() []*Submission {
	if m != nil {
		return m.Submissions
	}
	return nil
}

type LabResultLink struct {
	AuthorName           string        `protobuf:"bytes,1,opt,name=authorName,proto3" json:"authorName,omitempty"`
	Enrollment           *Enrollment   `protobuf:"bytes,2,opt,name=enrollment,proto3" json:"enrollment,omitempty"`
	Submissions          []*Submission `protobuf:"bytes,3,rep,name=submissions,proto3" json:"submissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LabResultLink) Reset()         { *m = LabResultLink{} }
func (m *LabResultLink) String() string { return proto.CompactTextString(m) }
func (*LabResultLink) ProtoMessage()    {}
func (*LabResultLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{16}
}
func (m *LabResultLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabResultLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabResultLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabResultLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabResultLink.Merge(m, src)
}
func (m *LabResultLink) XXX_Size() int {
	return m.Size()
}
func (m *LabResultLink) XXX_DiscardUnknown() {
	xxx_messageInfo_LabResultLink.DiscardUnknown(m)
}

var xxx_messageInfo_LabResultLink proto.InternalMessageInfo

func (m *LabResultLink) GetAuthorName() string {
	if m != nil {
		return m.AuthorName
	}
	return ""
}

func (m *LabResultLink) GetEnrollment() *Enrollment {
	if m != nil {
		return m.Enrollment
	}
	return nil
}

func (m *LabResultLink) GetSubmissions() []*Submission {
	if m != nil {
		return m.Submissions
	}
	return nil
}

type LabResultLinks struct {
	Labs                 []*LabResultLink `protobuf:"bytes,1,rep,name=labs,proto3" json:"labs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LabResultLinks) Reset()         { *m = LabResultLinks{} }
func (m *LabResultLinks) String() string { return proto.CompactTextString(m) }
func (*LabResultLinks) ProtoMessage()    {}
func (*LabResultLinks) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{17}
}
func (m *LabResultLinks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabResultLinks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabResultLinks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabResultLinks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabResultLinks.Merge(m, src)
}
func (m *LabResultLinks) XXX_Size() int {
	return m.Size()
}
func (m *LabResultLinks) XXX_DiscardUnknown() {
	xxx_messageInfo_LabResultLinks.DiscardUnknown(m)
}

var xxx_messageInfo_LabResultLinks proto.InternalMessageInfo

func (m *LabResultLinks) GetLabs() []*LabResultLink {
	if m != nil {
		return m.Labs
	}
	return nil
}

type CourseRequest struct {
	CourseID             uint64   `protobuf:"varint,1,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CourseRequest) Reset()         { *m = CourseRequest{} }
func (m *CourseRequest) String() string { return proto.CompactTextString(m) }
func (*CourseRequest) ProtoMessage()    {}
func (*CourseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{18}
}
func (m *CourseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CourseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CourseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CourseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CourseRequest.Merge(m, src)
}
func (m *CourseRequest) XXX_Size() int {
	return m.Size()
}
func (m *CourseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CourseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CourseRequest proto.InternalMessageInfo

func (m *CourseRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type CoursesListRequest struct {
	UserID               uint64                  `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	States               []Enrollment_UserStatus `protobuf:"varint,2,rep,packed,name=states,proto3,enum=Enrollment_UserStatus" json:"states,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CoursesListRequest) Reset()         { *m = CoursesListRequest{} }
func (m *CoursesListRequest) String() string { return proto.CompactTextString(m) }
func (*CoursesListRequest) ProtoMessage()    {}
func (*CoursesListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{19}
}
func (m *CoursesListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoursesListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoursesListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoursesListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoursesListRequest.Merge(m, src)
}
func (m *CoursesListRequest) XXX_Size() int {
	return m.Size()
}
func (m *CoursesListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CoursesListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CoursesListRequest proto.InternalMessageInfo

func (m *CoursesListRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *CoursesListRequest) GetStates() []Enrollment_UserStatus {
	if m != nil {
		return m.States
	}
	return nil
}

type GetGroupRequest struct {
	GroupID              uint64   `protobuf:"varint,1,opt,name=groupID,proto3" json:"groupID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGroupRequest) Reset()         { *m = GetGroupRequest{} }
func (m *GetGroupRequest) String() string { return proto.CompactTextString(m) }
func (*GetGroupRequest) ProtoMessage()    {}
func (*GetGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{20}
}
func (m *GetGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGroupRequest.Merge(m, src)
}
func (m *GetGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetGroupRequest proto.InternalMessageInfo

func (m *GetGroupRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

type GroupRequest struct {
	UserID               uint64   `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64   `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	CourseID             uint64   `protobuf:"varint,3,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GroupRequest) Reset()         { *m = GroupRequest{} }
func (m *GroupRequest) String() string { return proto.CompactTextString(m) }
func (*GroupRequest) ProtoMessage()    {}
func (*GroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{21}
}
func (m *GroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupRequest.Merge(m, src)
}
func (m *GroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *GroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GroupRequest proto.InternalMessageInfo

func (m *GroupRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GroupRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *GroupRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type Provider struct {
	Provider             string   `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Provider) Reset()         { *m = Provider{} }
func (m *Provider) String() string { return proto.CompactTextString(m) }
func (*Provider) ProtoMessage()    {}
func (*Provider) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{22}
}
func (m *Provider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Provider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Provider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Provider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Provider.Merge(m, src)
}
func (m *Provider) XXX_Size() int {
	return m.Size()
}
func (m *Provider) XXX_DiscardUnknown() {
	xxx_messageInfo_Provider.DiscardUnknown(m)
}

var xxx_messageInfo_Provider proto.InternalMessageInfo

func (m *Provider) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type OrgRequest struct {
	OrgName              string   `protobuf:"bytes,1,opt,name=orgName,proto3" json:"orgName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrgRequest) Reset()         { *m = OrgRequest{} }
func (m *OrgRequest) String() string { return proto.CompactTextString(m) }
func (*OrgRequest) ProtoMessage()    {}
func (*OrgRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{23}
}
func (m *OrgRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrgRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrgRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrgRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrgRequest.Merge(m, src)
}
func (m *OrgRequest) XXX_Size() int {
	return m.Size()
}
func (m *OrgRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OrgRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OrgRequest proto.InternalMessageInfo

func (m *OrgRequest) GetOrgName() string {
	if m != nil {
		return m.OrgName
	}
	return ""
}

// depending on situation frontend will have all enrolled users or only those that are not members of any group
// set filterOutGroupMembers go get list of students not belonging to any group for given course
type EnrollmentRequest struct {
	CourseID              uint64                  `protobuf:"varint,1,opt,name=courseID,proto3" json:"courseID,omitempty"`
	FilterOutGroupMembers bool                    `protobuf:"varint,2,opt,name=filterOutGroupMembers,proto3" json:"filterOutGroupMembers,omitempty"`
	States                []Enrollment_UserStatus `protobuf:"varint,3,rep,packed,name=states,proto3,enum=Enrollment_UserStatus" json:"states,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                `json:"-"`
	XXX_unrecognized      []byte                  `json:"-"`
	XXX_sizecache         int32                   `json:"-"`
}

func (m *EnrollmentRequest) Reset()         { *m = EnrollmentRequest{} }
func (m *EnrollmentRequest) String() string { return proto.CompactTextString(m) }
func (*EnrollmentRequest) ProtoMessage()    {}
func (*EnrollmentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{24}
}
func (m *EnrollmentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrollmentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnrollmentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnrollmentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrollmentRequest.Merge(m, src)
}
func (m *EnrollmentRequest) XXX_Size() int {
	return m.Size()
}
func (m *EnrollmentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrollmentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnrollmentRequest proto.InternalMessageInfo

func (m *EnrollmentRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *EnrollmentRequest) GetFilterOutGroupMembers() bool {
	if m != nil {
		return m.FilterOutGroupMembers
	}
	return false
}

func (m *EnrollmentRequest) GetStates() []Enrollment_UserStatus {
	if m != nil {
		return m.States
	}
	return nil
}

type SubmissionRequest struct {
	UserID               uint64   `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64   `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	CourseID             uint64   `protobuf:"varint,3,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmissionRequest) Reset()         { *m = SubmissionRequest{} }
func (m *SubmissionRequest) String() string { return proto.CompactTextString(m) }
func (*SubmissionRequest) ProtoMessage()    {}
func (*SubmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{25}
}
func (m *SubmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmissionRequest.Merge(m, src)
}
func (m *SubmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmissionRequest proto.InternalMessageInfo

func (m *SubmissionRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *SubmissionRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *SubmissionRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type ApproveSubmissionRequest struct {
	SubmissionID         uint64   `protobuf:"varint,1,opt,name=submissionID,proto3" json:"submissionID,omitempty"`
	CourseID             uint64   `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApproveSubmissionRequest) Reset()         { *m = ApproveSubmissionRequest{} }
func (m *ApproveSubmissionRequest) String() string { return proto.CompactTextString(m) }
func (*ApproveSubmissionRequest) ProtoMessage()    {}
func (*ApproveSubmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{26}
}
func (m *ApproveSubmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApproveSubmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApproveSubmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApproveSubmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApproveSubmissionRequest.Merge(m, src)
}
func (m *ApproveSubmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ApproveSubmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApproveSubmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApproveSubmissionRequest proto.InternalMessageInfo

func (m *ApproveSubmissionRequest) GetSubmissionID() uint64 {
	if m != nil {
		return m.SubmissionID
	}
	return 0
}

func (m *ApproveSubmissionRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type Providers struct {
	Providers            []string `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Providers) Reset()         { *m = Providers{} }
func (m *Providers) String() string { return proto.CompactTextString(m) }
func (*Providers) ProtoMessage()    {}
func (*Providers) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{27}
}
func (m *Providers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Providers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Providers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Providers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Providers.Merge(m, src)
}
func (m *Providers) XXX_Size() int {
	return m.Size()
}
func (m *Providers) XXX_DiscardUnknown() {
	xxx_messageInfo_Providers.DiscardUnknown(m)
}

var xxx_messageInfo_Providers proto.InternalMessageInfo

func (m *Providers) GetProviders() []string {
	if m != nil {
		return m.Providers
	}
	return nil
}

type URLRequest struct {
	CourseID             uint64            `protobuf:"varint,1,opt,name=courseID,proto3" json:"courseID,omitempty"`
	RepoTypes            []Repository_Type `protobuf:"varint,2,rep,packed,name=repoTypes,proto3,enum=Repository_Type" json:"repoTypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *URLRequest) Reset()         { *m = URLRequest{} }
func (m *URLRequest) String() string { return proto.CompactTextString(m) }
func (*URLRequest) ProtoMessage()    {}
func (*URLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{28}
}
func (m *URLRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *URLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLRequest.Merge(m, src)
}
func (m *URLRequest) XXX_Size() int {
	return m.Size()
}
func (m *URLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_URLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_URLRequest proto.InternalMessageInfo

func (m *URLRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *URLRequest) GetRepoTypes() []Repository_Type {
	if m != nil {
		return m.RepoTypes
	}
	return nil
}

// used to check whether student/group submission repo is empty
type RepositoryRequest struct {
	UserID               uint64   `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64   `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	CourseID             uint64   `protobuf:"varint,3,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepositoryRequest) Reset()         { *m = RepositoryRequest{} }
func (m *RepositoryRequest) String() string { return proto.CompactTextString(m) }
func (*RepositoryRequest) ProtoMessage()    {}
func (*RepositoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{29}
}
func (m *RepositoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepositoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepositoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepositoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepositoryRequest.Merge(m, src)
}
func (m *RepositoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *RepositoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RepositoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RepositoryRequest proto.InternalMessageInfo

func (m *RepositoryRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *RepositoryRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RepositoryRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type Repositories struct {
	URLs                 map[string]string `protobuf:"bytes,1,rep,name=URLs,proto3" json:"URLs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Repositories) Reset()         { *m = Repositories{} }
func (m *Repositories) String() string { return proto.CompactTextString(m) }
func (*Repositories) ProtoMessage()    {}
func (*Repositories) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{30}
}
func (m *Repositories) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repositories) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repositories.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repositories) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repositories.Merge(m, src)
}
func (m *Repositories) XXX_Size() int {
	return m.Size()
}
func (m *Repositories) XXX_DiscardUnknown() {
	xxx_messageInfo_Repositories.DiscardUnknown(m)
}

var xxx_messageInfo_Repositories proto.InternalMessageInfo

func (m *Repositories) GetURLs() map[string]string {
	if m != nil {
		return m.URLs
	}
	return nil
}

type AuthorizationResponse struct {
	IsAuthorized         bool     `protobuf:"varint,1,opt,name=IsAuthorized,proto3" json:"IsAuthorized,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthorizationResponse) Reset()         { *m = AuthorizationResponse{} }
func (m *AuthorizationResponse) String() string { return proto.CompactTextString(m) }
func (*AuthorizationResponse) ProtoMessage()    {}
func (*AuthorizationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{31}
}
func (m *AuthorizationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationResponse.Merge(m, src)
}
func (m *AuthorizationResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationResponse proto.InternalMessageInfo

func (m *AuthorizationResponse) GetIsAuthorized() bool {
	if m != nil {
		return m.IsAuthorized
	}
	return false
}

type Status struct {
	Code                 uint64   `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{32}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type LabRequest struct {
	CourseID             uint64   `protobuf:"varint,1,opt,name=courseID,proto3" json:"courseID,omitempty"`
	SubmissionID         uint64   `protobuf:"varint,2,opt,name=submissionID,proto3" json:"submissionID,omitempty"`
	AssignmentID         uint64   `protobuf:"varint,3,opt,name=assignmentID,proto3" json:"assignmentID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabRequest) Reset()         { *m = LabRequest{} }
func (m *LabRequest) String() string { return proto.CompactTextString(m) }
func (*LabRequest) ProtoMessage()    {}
func (*LabRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{33}
}
func (m *LabRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabRequest.Merge(m, src)
}
func (m *LabRequest) XXX_Size() int {
	return m.Size()
}
func (m *LabRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LabRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LabRequest proto.InternalMessageInfo

func (m *LabRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *LabRequest) GetSubmissionID() uint64 {
	if m != nil {
		return m.SubmissionID
	}
	return 0
}

func (m *LabRequest) GetAssignmentID() uint64 {
	if m != nil {
		return m.AssignmentID
	}
	return 0
}

// messages of type Void used when we want a boolean answer from the server
// GRPC status code 0 indicates that the requested action was a success
// any other status will include a message explaining what went wrong
type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{34}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("Group_GroupStatus", Group_GroupStatus_name, Group_GroupStatus_value)
	proto.RegisterEnum("Repository_Type", Repository_Type_name, Repository_Type_value)
	proto.RegisterEnum("Enrollment_UserStatus", Enrollment_UserStatus_name, Enrollment_UserStatus_value)
	proto.RegisterType((*User)(nil), "User")
	proto.RegisterType((*Users)(nil), "Users")
	proto.RegisterType((*RemoteIdentity)(nil), "RemoteIdentity")
	proto.RegisterType((*Group)(nil), "Group")
	proto.RegisterType((*Groups)(nil), "Groups")
	proto.RegisterType((*Course)(nil), "Course")
	proto.RegisterType((*Courses)(nil), "Courses")
	proto.RegisterType((*Repository)(nil), "Repository")
	proto.RegisterType((*Organization)(nil), "Organization")
	proto.RegisterType((*Organizations)(nil), "Organizations")
	proto.RegisterType((*Enrollment)(nil), "Enrollment")
	proto.RegisterType((*Enrollments)(nil), "Enrollments")
	proto.RegisterType((*Assignment)(nil), "Assignment")
	proto.RegisterType((*Assignments)(nil), "Assignments")
	proto.RegisterType((*Submission)(nil), "Submission")
	proto.RegisterType((*Submissions)(nil), "Submissions")
	proto.RegisterType((*LabResultLink)(nil), "LabResultLink")
	proto.RegisterType((*LabResultLinks)(nil), "LabResultLinks")
	proto.RegisterType((*CourseRequest)(nil), "CourseRequest")
	proto.RegisterType((*CoursesListRequest)(nil), "CoursesListRequest")
	proto.RegisterType((*GetGroupRequest)(nil), "GetGroupRequest")
	proto.RegisterType((*GroupRequest)(nil), "GroupRequest")
	proto.RegisterType((*Provider)(nil), "Provider")
	proto.RegisterType((*OrgRequest)(nil), "OrgRequest")
	proto.RegisterType((*EnrollmentRequest)(nil), "EnrollmentRequest")
	proto.RegisterType((*SubmissionRequest)(nil), "SubmissionRequest")
	proto.RegisterType((*ApproveSubmissionRequest)(nil), "ApproveSubmissionRequest")
	proto.RegisterType((*Providers)(nil), "Providers")
	proto.RegisterType((*URLRequest)(nil), "URLRequest")
	proto.RegisterType((*RepositoryRequest)(nil), "RepositoryRequest")
	proto.RegisterType((*Repositories)(nil), "Repositories")
	proto.RegisterMapType((map[string]string)(nil), "Repositories.URLsEntry")
	proto.RegisterType((*AuthorizationResponse)(nil), "AuthorizationResponse")
	proto.RegisterType((*Status)(nil), "Status")
	proto.RegisterType((*LabRequest)(nil), "LabRequest")
	proto.RegisterType((*Void)(nil), "Void")
}

func init() { proto.RegisterFile("ag.proto", fileDescriptor_7a984e8f57169aa1) }

var fileDescriptor_7a984e8f57169aa1 = []byte{
	// 2068 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x49, 0x6f, 0x1b, 0xc9,
	0xf5, 0x57, 0x93, 0xcd, 0xed, 0x71, 0x31, 0x55, 0x33, 0xe3, 0xa1, 0x39, 0x86, 0xa4, 0x7f, 0xfd,
	0x13, 0x41, 0xde, 0xda, 0x81, 0xc6, 0x98, 0x49, 0xec, 0x01, 0x02, 0x4a, 0xec, 0xc8, 0x9c, 0xd0,
	0xa4, 0x50, 0x24, 0x27, 0x41, 0x30, 0x80, 0xd2, 0x24, 0xcb, 0x54, 0xc7, 0x64, 0x37, 0xdd, 0x8b,
	0x31, 0xca, 0x2d, 0x97, 0x00, 0x41, 0x8e, 0x41, 0x80, 0xdc, 0xf2, 0x65, 0x72, 0xc8, 0x31, 0x9f,
	0xc0, 0x08, 0x7c, 0xcf, 0xc5, 0x9f, 0x20, 0xa8, 0xa5, 0xbb, 0xab, 0xd9, 0x5a, 0x3c, 0x01, 0xe6,
	0x22, 0xf5, 0xdb, 0xaa, 0xde, 0x56, 0xbf, 0x7a, 0x45, 0x28, 0x5b, 0x0b, 0x63, 0xed, 0xb9, 0x81,
	0xdb, 0x7e, 0xb4, 0xb0, 0x83, 0xf3, 0x70, 0x6a, 0xcc, 0xdc, 0xd5, 0xe3, 0x85, 0xbb, 0x70, 0x1f,
	0x73, 0xf6, 0x34, 0x7c, 0xc9, 0x29, 0x4e, 0xf0, 0x2f, 0xa1, 0x8e, 0xff, 0x96, 0x03, 0x7d, 0xe2,
	0x53, 0x0f, 0x35, 0x20, 0xd7, 0xeb, 0xb6, 0xb4, 0x3d, 0xed, 0x40, 0x27, 0xb9, 0x5e, 0x17, 0xb5,
	0xa0, 0x64, 0xfb, 0x9d, 0xf9, 0xca, 0x76, 0x5a, 0xb9, 0x3d, 0xed, 0xa0, 0x4c, 0x22, 0x12, 0x21,
	0xd0, 0x1d, 0x6b, 0x45, 0x5b, 0xf9, 0x3d, 0xed, 0xa0, 0x42, 0xf8, 0x37, 0xba, 0x0b, 0x15, 0x3f,
	0x08, 0xe7, 0xd4, 0x09, 0x7a, 0xdd, 0x96, 0xce, 0x05, 0x09, 0x03, 0x7d, 0x0c, 0x05, 0xba, 0xb2,
	0xec, 0x65, 0xab, 0xc0, 0x25, 0x82, 0x60, 0x36, 0xd6, 0x1b, 0x2b, 0xb0, 0xbc, 0x09, 0xe9, 0xb7,
	0x8a, 0xc2, 0x26, 0x66, 0x30, 0x9b, 0xa5, 0xbb, 0xb0, 0x9d, 0x56, 0x49, 0xd8, 0x70, 0x02, 0x3d,
	0x83, 0xa6, 0x47, 0x57, 0x6e, 0x40, 0x7b, 0x6c, 0x69, 0x3b, 0xb0, 0xa9, 0xdf, 0x2a, 0xef, 0xe5,
	0x0f, 0xaa, 0x87, 0xb7, 0x0c, 0xa2, 0x0a, 0x2e, 0x48, 0x46, 0x11, 0x3d, 0x82, 0x2a, 0x75, 0x3c,
	0x77, 0xb9, 0x5c, 0x51, 0x27, 0xf0, 0x5b, 0x15, 0x6e, 0x57, 0x35, 0xcc, 0x98, 0x47, 0x54, 0x39,
	0xfe, 0x11, 0x14, 0x58, 0x66, 0x7c, 0xf4, 0x19, 0x14, 0x42, 0xf6, 0xd1, 0xd2, 0xb8, 0x45, 0xc1,
	0x60, 0x6c, 0x22, 0x78, 0xf8, 0xbd, 0x06, 0x8d, 0xf4, 0xce, 0x99, 0x54, 0x7e, 0x0d, 0xe5, 0xb5,
	0xe7, 0xbe, 0xb1, 0xe7, 0xd4, 0xe3, 0xb9, 0xac, 0x1c, 0x19, 0xef, 0xdf, 0xee, 0xde, 0x5f, 0xb8,
	0xde, 0xea, 0x29, 0x0e, 0x1d, 0xfb, 0x75, 0x48, 0xcf, 0x6c, 0x67, 0x4e, 0xbf, 0x7b, 0x1a, 0xda,
	0xf3, 0xb3, 0x48, 0xf5, 0x4c, 0xf8, 0x7f, 0x66, 0xcf, 0x31, 0x89, 0xed, 0xd9, 0x5a, 0x32, 0xae,
	0x2e, 0x2f, 0x80, 0xfe, 0xfd, 0xd7, 0x8a, 0xec, 0xd1, 0x1e, 0x54, 0xad, 0xd9, 0x8c, 0xfa, 0xfe,
	0xd8, 0x7d, 0x45, 0x1d, 0x59, 0x36, 0x95, 0x85, 0x6e, 0x43, 0x91, 0x45, 0xd9, 0xeb, 0xf2, 0xca,
	0xe9, 0x44, 0x52, 0xf8, 0x3f, 0x39, 0x28, 0x9c, 0x78, 0x6e, 0xb8, 0xce, 0xc4, 0xda, 0x91, 0xcd,
	0x21, 0xe2, 0x7c, 0xf4, 0xfe, 0xed, 0xee, 0xbd, 0x4b, 0x7c, 0xb3, 0xe7, 0xdf, 0x9d, 0x49, 0xc6,
	0x82, 0x2d, 0x73, 0xc6, 0x6c, 0xb0, 0xec, 0xa5, 0x1e, 0x94, 0x67, 0x6e, 0xe8, 0xf9, 0x49, 0x88,
	0xdf, 0x73, 0x99, 0xd8, 0x9c, 0xf9, 0x1f, 0x50, 0x6b, 0x25, 0x7b, 0x52, 0x27, 0x92, 0x42, 0xf7,
	0xa1, 0xe8, 0x07, 0x56, 0x10, 0xfa, 0x3c, 0xae, 0xc6, 0x21, 0x32, 0x78, 0x34, 0xe2, 0xef, 0x88,
	0x4b, 0x88, 0xd4, 0x48, 0xaa, 0x5f, 0xcc, 0x56, 0x7f, 0xb3, 0xa5, 0x4a, 0x37, 0xb4, 0xd4, 0x17,
	0x50, 0x55, 0xb6, 0x40, 0x55, 0x28, 0x9d, 0x9a, 0x83, 0x6e, 0x6f, 0x70, 0xd2, 0xdc, 0x42, 0x35,
	0x28, 0x13, 0xf3, 0x6b, 0xf3, 0x78, 0x6c, 0x76, 0x9b, 0x1a, 0xa3, 0x3a, 0xa7, 0xa7, 0x64, 0xf8,
	0x8d, 0xd9, 0x6d, 0xe6, 0xf0, 0x01, 0x14, 0xb9, 0x9d, 0x8f, 0x76, 0xa0, 0xc8, 0x43, 0x8d, 0x9a,
	0xb1, 0x28, 0x7c, 0x26, 0x92, 0x8b, 0xff, 0x92, 0x87, 0xe2, 0x31, 0x0f, 0x3f, 0x53, 0x9a, 0x03,
	0xb8, 0x25, 0x12, 0x73, 0xec, 0x51, 0x2b, 0x70, 0x59, 0x55, 0x73, 0x5c, 0xb8, 0xc9, 0xbe, 0xf4,
	0x84, 0x23, 0xd0, 0x67, 0xee, 0x9c, 0xca, 0x2e, 0xe1, 0xdf, 0x8c, 0x77, 0x41, 0x2d, 0x8f, 0x27,
	0xb1, 0x4e, 0xf8, 0x37, 0x6a, 0x42, 0x3e, 0xb0, 0x16, 0xf2, 0x3c, 0xb3, 0x4f, 0xd4, 0x56, 0xda,
	0x5f, 0x1c, 0xe6, 0xa4, 0x9d, 0xf7, 0xa1, 0xe1, 0x7a, 0x0b, 0xcb, 0xb1, 0x7f, 0x6f, 0x05, 0xb6,
	0xeb, 0xf4, 0xba, 0xad, 0x32, 0x77, 0x69, 0x83, 0x8b, 0x7e, 0x0e, 0x65, 0x91, 0x47, 0x3a, 0x6f,
	0x55, 0x78, 0xc9, 0x6e, 0x2b, 0x49, 0xe6, 0x25, 0x11, 0x39, 0x3d, 0xaa, 0xbe, 0x7f, 0xbb, 0x5b,
	0xf2, 0x5f, 0x2f, 0x9f, 0xe2, 0x47, 0x98, 0xc4, 0x46, 0x9b, 0x85, 0x82, 0xeb, 0x0b, 0xc5, 0xd4,
	0x2d, 0xdf, 0xb7, 0x17, 0x8e, 0x50, 0xaf, 0x49, 0xf5, 0x4e, 0xcc, 0x23, 0xaa, 0x5c, 0xa9, 0x4a,
	0xfd, 0xd2, 0xaa, 0x3c, 0x84, 0x92, 0x28, 0x8a, 0x8f, 0xfe, 0x0f, 0x4a, 0x22, 0xdd, 0x51, 0x05,
	0x4b, 0x86, 0x10, 0x91, 0x88, 0x8f, 0xff, 0x91, 0x03, 0x20, 0x74, 0xed, 0xfa, 0x76, 0xe0, 0x7a,
	0x59, 0x38, 0xc9, 0xe6, 0x2c, 0x77, 0x69, 0xce, 0x30, 0xd4, 0xbc, 0x78, 0x95, 0xe8, 0x2c, 0x91,
	0x14, 0x4f, 0x39, 0xe0, 0xba, 0x7a, 0xc0, 0x19, 0xfa, 0x73, 0xd7, 0xe3, 0x93, 0x1f, 0x91, 0x4c,
	0xf2, 0x7c, 0xfc, 0xa2, 0x9f, 0x60, 0x76, 0x44, 0xa2, 0x87, 0x0c, 0x9a, 0xd6, 0xee, 0xf8, 0x62,
	0x4d, 0x79, 0x9d, 0x1b, 0x87, 0x4d, 0x23, 0x09, 0xc3, 0x60, 0x7c, 0x12, 0x6b, 0xe0, 0xdf, 0x82,
	0xce, 0xfe, 0xa3, 0x32, 0xe8, 0x83, 0xe1, 0xc0, 0x6c, 0x6e, 0xa1, 0x06, 0xc0, 0xf1, 0x70, 0x42,
	0x46, 0x66, 0x6f, 0xf0, 0x8b, 0x61, 0x53, 0x43, 0xb7, 0xa0, 0xda, 0x19, 0x8d, 0x7a, 0x27, 0x83,
	0x17, 0xe6, 0x60, 0x3c, 0x6a, 0xe6, 0x50, 0x05, 0x0a, 0x63, 0x73, 0x34, 0x1e, 0x35, 0xf3, 0xa8,
	0x0e, 0x95, 0xd1, 0xb0, 0x3f, 0x19, 0xf7, 0x86, 0x83, 0x51, 0x53, 0x67, 0x8b, 0x4c, 0x46, 0x26,
	0x69, 0x16, 0x98, 0xce, 0x09, 0x19, 0x4e, 0x4e, 0x9b, 0x45, 0xbc, 0x84, 0xda, 0x50, 0xc9, 0x48,
	0x26, 0x8f, 0x08, 0xf4, 0xb5, 0x15, 0x9c, 0x0b, 0xa8, 0x22, 0xfc, 0x9b, 0xe5, 0x43, 0x5c, 0x41,
	0xb2, 0xf7, 0x25, 0xc5, 0xa0, 0x72, 0x6d, 0x5d, 0xb0, 0x62, 0x9f, 0x2e, 0xad, 0x18, 0x2a, 0x15,
	0x16, 0xee, 0x42, 0x5d, 0xdd, 0xcd, 0x47, 0x9f, 0x43, 0x5d, 0x2d, 0x48, 0x54, 0xee, 0xba, 0xa1,
	0xaa, 0x91, 0xb4, 0x0e, 0xfe, 0x7b, 0x1e, 0x20, 0xe9, 0xc9, 0x8c, 0xcb, 0x2a, 0x34, 0xe6, 0x3e,
	0x14, 0x1a, 0x93, 0xbe, 0x56, 0xa1, 0xd1, 0x8c, 0x2b, 0x9f, 0xff, 0x5f, 0x16, 0xba, 0xa4, 0x51,
	0xf4, 0x74, 0xa3, 0xdc, 0x01, 0x9d, 0xe9, 0xf0, 0xfe, 0x89, 0x61, 0x93, 0xb3, 0xd0, 0x2e, 0x14,
	0x85, 0x1f, 0xbc, 0x85, 0x94, 0x23, 0x20, 0xd9, 0xe8, 0x2e, 0x14, 0xf8, 0x32, 0xbc, 0x8f, 0x92,
	0xe3, 0x24, 0x98, 0xc8, 0x88, 0xd1, 0xbb, 0x7c, 0x1d, 0x14, 0x44, 0x08, 0x8e, 0x7f, 0x09, 0x90,
	0x70, 0x95, 0x86, 0x53, 0xe0, 0x57, 0x4b, 0xc1, 0x6f, 0x8e, 0x89, 0x46, 0xe3, 0x49, 0xd7, 0x1c,
	0x8c, 0x9b, 0x79, 0x46, 0x8c, 0xcd, 0xce, 0xf1, 0x73, 0x93, 0x34, 0x75, 0xfc, 0x15, 0x54, 0xcd,
	0x34, 0x50, 0xa8, 0xb8, 0xa2, 0xdd, 0x70, 0x01, 0xfc, 0x29, 0x07, 0x90, 0x80, 0x48, 0xa6, 0xbe,
	0xed, 0xcd, 0xfa, 0x2a, 0x05, 0xbb, 0x0c, 0x94, 0xdb, 0x50, 0x5e, 0x5a, 0xce, 0x22, 0xb4, 0x16,
	0x11, 0x30, 0xc7, 0x34, 0x93, 0xcd, 0xa9, 0x35, 0x5f, 0xda, 0x0e, 0x95, 0x73, 0x57, 0x4c, 0xf3,
	0x9b, 0x3f, 0x0c, 0xdc, 0xce, 0x9a, 0x01, 0xb1, 0xa8, 0x42, 0x99, 0xa8, 0x2c, 0x36, 0x7e, 0xb9,
	0x5e, 0x84, 0xd8, 0x75, 0x22, 0x08, 0xb4, 0x03, 0x60, 0xfb, 0xbc, 0x16, 0x7d, 0x6b, 0xca, 0xb3,
	0x5f, 0x26, 0x0a, 0x07, 0x3d, 0x00, 0xf0, 0xc3, 0xe9, 0xca, 0xf6, 0x7d, 0xdb, 0x75, 0x38, 0x50,
	0xb3, 0x64, 0x8c, 0x62, 0x16, 0x51, 0xc4, 0x2c, 0x93, 0x1d, 0x05, 0x43, 0x37, 0x20, 0x57, 0xbb,
	0x1e, 0x72, 0xf1, 0x1f, 0x73, 0x00, 0xc9, 0xc2, 0x99, 0x4c, 0x62, 0xa8, 0x25, 0xda, 0x71, 0x36,
	0x53, 0x3c, 0x05, 0xfc, 0xf2, 0x57, 0x81, 0xdf, 0x46, 0x4f, 0x7f, 0x0c, 0x05, 0x7f, 0xe6, 0x7a,
	0x54, 0xde, 0x78, 0x82, 0x60, 0x7b, 0xf1, 0x8f, 0xe1, 0xf4, 0x77, 0x74, 0x16, 0xf8, 0x12, 0x17,
	0x53, 0x3c, 0x36, 0xec, 0x4e, 0x43, 0x7b, 0x39, 0xef, 0x39, 0x2f, 0x5d, 0x79, 0x0b, 0x26, 0x0c,
	0x96, 0xd7, 0x99, 0xbb, 0x5a, 0xd9, 0xc1, 0x73, 0xcb, 0x3f, 0xe7, 0x79, 0xad, 0x10, 0x85, 0xc3,
	0x6a, 0x69, 0x89, 0xc2, 0x88, 0xeb, 0xaf, 0x4c, 0x62, 0x9a, 0xa5, 0x31, 0xc9, 0x03, 0x4f, 0x63,
	0x92, 0xe3, 0x24, 0x8d, 0x4a, 0x0d, 0x54, 0x39, 0xfe, 0xb3, 0x06, 0xf5, 0xbe, 0x35, 0x25, 0xd4,
	0x0f, 0x97, 0x41, 0xdf, 0x76, 0x5e, 0x31, 0x5f, 0xac, 0x30, 0x38, 0x77, 0xbd, 0x01, 0xeb, 0x36,
	0x4d, 0xf8, 0x92, 0x70, 0x58, 0x8d, 0x93, 0x8e, 0xe6, 0x79, 0xdd, 0x68, 0x78, 0x45, 0xbc, 0xe9,
	0x4d, 0xfe, 0x06, 0x6f, 0x9e, 0x40, 0x23, 0xe5, 0x8c, 0x8f, 0x30, 0xe8, 0x4b, 0x6b, 0x1a, 0xc5,
	0xd1, 0x30, 0x52, 0x62, 0xc2, 0x65, 0xf8, 0x01, 0xd4, 0x25, 0x7e, 0xd0, 0xd7, 0x21, 0xf5, 0x83,
	0xd4, 0x31, 0xd2, 0xd2, 0xc7, 0x08, 0x7f, 0x0b, 0x48, 0x5e, 0xc5, 0x7d, 0xdb, 0x0f, 0x22, 0x8b,
	0xa4, 0x15, 0xb4, 0x54, 0x2b, 0x48, 0xa8, 0xa1, 0x7e, 0x2b, 0xb7, 0x97, 0xbf, 0x09, 0x6a, 0x28,
	0x73, 0xe5, 0xd6, 0x09, 0x0d, 0x04, 0x5a, 0xc9, 0xa5, 0x95, 0x6e, 0xd2, 0x52, 0xdd, 0x84, 0xbf,
	0x85, 0x5a, 0x4a, 0xf3, 0x2a, 0x27, 0x94, 0x15, 0x72, 0xe9, 0x7e, 0x6c, 0x6f, 0x8e, 0xca, 0x4a,
	0xa0, 0xfb, 0x50, 0x3e, 0x8d, 0xc6, 0x2c, 0x75, 0x04, 0xd3, 0xd2, 0x23, 0x18, 0xde, 0x07, 0x18,
	0x7a, 0x0b, 0xc5, 0x5b, 0xd7, 0x5b, 0x28, 0xa5, 0x8f, 0x48, 0xfc, 0x57, 0x0d, 0xb6, 0x95, 0x2a,
	0xdf, 0x9c, 0x6a, 0xf4, 0x04, 0x3e, 0x79, 0x69, 0x2f, 0x03, 0xea, 0x0d, 0x43, 0x91, 0x92, 0x17,
	0x74, 0x35, 0x65, 0x93, 0xb4, 0x78, 0x50, 0x5e, 0x2e, 0x54, 0x52, 0x9e, 0xff, 0xa0, 0x94, 0x5b,
	0xb0, 0xad, 0xb4, 0xd3, 0x0f, 0x92, 0xca, 0xdf, 0x40, 0x4b, 0xe2, 0x62, 0x76, 0x27, 0x76, 0xf8,
	0x63, 0x66, 0xbc, 0x5f, 0x8a, 0x77, 0x1d, 0xac, 0xe3, 0x7b, 0x50, 0x89, 0xca, 0xc4, 0x51, 0x22,
	0xaa, 0x8b, 0x68, 0xf9, 0x0a, 0x49, 0x18, 0xf8, 0xd7, 0x00, 0x13, 0xd2, 0xff, 0x90, 0xcc, 0x1b,
	0x50, 0x89, 0x06, 0xad, 0xa8, 0x73, 0xb3, 0xb3, 0x58, 0xa2, 0xc2, 0x72, 0x98, 0x48, 0x7f, 0x98,
	0x1c, 0x06, 0x50, 0x8b, 0xb7, 0x60, 0x8f, 0xf1, 0x07, 0xa0, 0x4f, 0x48, 0x3f, 0x3a, 0xd8, 0x9f,
	0x1a, 0xaa, 0xd0, 0x60, 0x12, 0xd3, 0x09, 0xbc, 0x0b, 0xc2, 0x95, 0xda, 0x5f, 0x42, 0x25, 0x66,
	0xb1, 0x17, 0xc6, 0x2b, 0x7a, 0x21, 0xdb, 0x93, 0x7d, 0x32, 0x58, 0x7e, 0x63, 0x2d, 0x43, 0xf9,
	0xea, 0x24, 0x82, 0x78, 0x9a, 0xfb, 0xa9, 0x86, 0x9f, 0xc1, 0x27, 0x1d, 0x0e, 0x5d, 0xd1, 0xbc,
	0x45, 0xfd, 0xb5, 0xeb, 0xf8, 0x1c, 0xb3, 0x7b, 0x7e, 0x24, 0xa2, 0x73, 0xbe, 0x5a, 0x99, 0xa4,
	0x78, 0xf8, 0x10, 0x8a, 0x72, 0x66, 0x40, 0xa0, 0x1f, 0xb3, 0xc7, 0x8f, 0x48, 0x04, 0xff, 0x66,
	0x9b, 0x9a, 0x9e, 0xe7, 0x7a, 0xd1, 0xa6, 0x9c, 0xc0, 0x6b, 0x00, 0x0e, 0x51, 0x37, 0xd7, 0x68,
	0xb3, 0x71, 0x72, 0x97, 0x34, 0xce, 0xe6, 0x2d, 0x96, 0xcf, 0xde, 0x62, 0xb8, 0x08, 0xfa, 0x37,
	0xae, 0x3d, 0x3f, 0xfc, 0x03, 0xc0, 0x76, 0x27, 0x0c, 0xdc, 0x85, 0x67, 0xcd, 0xa9, 0x37, 0xa2,
	0xde, 0x1b, 0x7b, 0x46, 0xd1, 0x1d, 0x28, 0x9d, 0xd0, 0x80, 0xff, 0xc2, 0x53, 0x30, 0x98, 0x5e,
	0x5b, 0x4c, 0x62, 0x78, 0x0b, 0x7d, 0x06, 0x65, 0x29, 0xf2, 0x23, 0x59, 0x91, 0xcb, 0x7c, 0xbc,
	0x85, 0xee, 0x02, 0x4c, 0xd6, 0x73, 0x2b, 0xa0, 0xd2, 0x94, 0xfd, 0x4b, 0x4c, 0xbf, 0x80, 0x8f,
	0xd4, 0x4c, 0x8d, 0xa9, 0x35, 0x3b, 0x4f, 0x76, 0xb8, 0x6d, 0x5c, 0x9a, 0x73, 0xbc, 0x85, 0xf6,
	0xf9, 0x96, 0xe2, 0x97, 0x83, 0xa6, 0xb1, 0x81, 0x94, 0x6d, 0x39, 0xe6, 0xe1, 0x2d, 0x74, 0x08,
	0x9f, 0x46, 0xc2, 0xa3, 0x0b, 0xb6, 0x67, 0xc7, 0x99, 0xcb, 0x57, 0x6d, 0xdd, 0xb8, 0xc2, 0x66,
	0x1f, 0x2a, 0x91, 0x8d, 0x8f, 0x1a, 0x46, 0xea, 0x46, 0x68, 0x97, 0x84, 0x1a, 0x8b, 0x6c, 0x17,
	0xaa, 0xfc, 0xa5, 0x4b, 0x85, 0x1b, 0x72, 0x01, 0x65, 0xa1, 0x1d, 0xa8, 0x8a, 0xd0, 0xd3, 0x0a,
	0x22, 0x38, 0xbc, 0x85, 0x7e, 0x0c, 0xd5, 0x2e, 0x5d, 0xd2, 0x48, 0xbe, 0xe1, 0x50, 0xac, 0x26,
	0xfc, 0x89, 0xde, 0xe2, 0x19, 0x7f, 0x04, 0xcd, 0xfd, 0x81, 0x58, 0x2f, 0x2e, 0x44, 0x59, 0xca,
	0x99, 0xc3, 0xcf, 0xa0, 0x95, 0x28, 0xfc, 0xca, 0x0e, 0xce, 0x95, 0x07, 0xc2, 0x47, 0x46, 0xf6,
	0x32, 0x4b, 0x19, 0x63, 0xa8, 0x89, 0x68, 0xa5, 0x23, 0xd1, 0xc6, 0xaa, 0x07, 0x7b, 0x50, 0x13,
	0x01, 0x6f, 0xea, 0xc4, 0xb1, 0xfc, 0x04, 0x1a, 0x27, 0x34, 0x50, 0xa7, 0xb5, 0xcd, 0x80, 0x6a,
	0xca, 0xa0, 0xc6, 0xf6, 0x7d, 0x08, 0xdb, 0x62, 0xcd, 0xeb, 0x8c, 0xe2, 0xf5, 0xbf, 0x82, 0xdb,
	0x27, 0x34, 0x50, 0xe6, 0xea, 0xa3, 0x0b, 0xe9, 0x0b, 0x32, 0x32, 0x77, 0x4e, 0xbb, 0xa6, 0xf0,
	0xd8, 0x5e, 0x07, 0xd0, 0x14, 0x31, 0x2a, 0x89, 0x51, 0x27, 0x92, 0x64, 0x9f, 0x03, 0x68, 0x0a,
	0xaf, 0x6e, 0xd4, 0x8c, 0xfd, 0x57, 0x87, 0xfd, 0x2b, 0xfd, 0x7f, 0xc2, 0xf3, 0xa3, 0x8e, 0x61,
	0xc8, 0xc8, 0x5c, 0x15, 0xed, 0x9a, 0xc2, 0x63, 0x7e, 0x7f, 0x09, 0xdb, 0x99, 0x6b, 0x05, 0xdd,
	0x31, 0xae, 0xba, 0x6a, 0x92, 0xed, 0xee, 0x31, 0xb8, 0xe6, 0xd3, 0xa3, 0x62, 0x58, 0x35, 0x12,
	0xe0, 0x49, 0x54, 0x7f, 0xc6, 0x4f, 0x92, 0x70, 0xbb, 0x6f, 0x4d, 0x55, 0x17, 0x53, 0x06, 0xb7,
	0xd2, 0x93, 0x15, 0x73, 0xef, 0xff, 0xa1, 0x76, 0x42, 0x83, 0xe4, 0x72, 0x92, 0xad, 0x09, 0x46,
	0xcc, 0xc2, 0x5b, 0xe8, 0x31, 0x1f, 0x78, 0x52, 0xef, 0xec, 0xaa, 0x91, 0xcc, 0x13, 0xed, 0xf4,
	0x73, 0x37, 0x36, 0x48, 0x5d, 0x05, 0x55, 0x23, 0xb9, 0xd6, 0xda, 0xf5, 0xd4, 0x4d, 0x80, 0xb7,
	0xd0, 0x7d, 0xa8, 0xf6, 0x7c, 0x73, 0xb5, 0x0e, 0x2e, 0x98, 0x00, 0x21, 0x23, 0x73, 0x53, 0xc5,
	0xd1, 0x1e, 0xd5, 0xfe, 0xf9, 0x6e, 0x47, 0xfb, 0xd7, 0xbb, 0x1d, 0xed, 0xdf, 0xef, 0x76, 0xb4,
	0x69, 0x91, 0xff, 0xc4, 0xfd, 0xf9, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x72, 0x35, 0x82, 0x1f,
	0x1d, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AutograderServiceClient is the client API for AutograderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutograderServiceClient interface {
	GetUser(ctx context.Context, in *Void, opts ...grpc.CallOption) (*User, error)
	GetUsers(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Users, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	IsAuthorizedTeacher(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AuthorizationResponse, error)
	GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*Group, error)
	GetGroupByUserAndCourse(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error)
	GetGroups(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Groups, error)
	CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error)
	UpdateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error)
	DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Void, error)
	GetCourse(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Course, error)
	GetCourses(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Courses, error)
	GetCoursesWithEnrollment(ctx context.Context, in *CoursesListRequest, opts ...grpc.CallOption) (*Courses, error)
	CreateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Course, error)
	UpdateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Void, error)
	GetAssignments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Assignments, error)
	UpdateAssignments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Void, error)
	GetEnrollmentsByCourse(ctx context.Context, in *EnrollmentRequest, opts ...grpc.CallOption) (*Enrollments, error)
	CreateEnrollment(ctx context.Context, in *Enrollment, opts ...grpc.CallOption) (*Void, error)
	UpdateEnrollment(ctx context.Context, in *Enrollment, opts ...grpc.CallOption) (*Void, error)
	UpdateEnrollments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Void, error)
	GetSubmissions(ctx context.Context, in *SubmissionRequest, opts ...grpc.CallOption) (*Submissions, error)
	ApproveSubmission(ctx context.Context, in *ApproveSubmissionRequest, opts ...grpc.CallOption) (*Void, error)
	RebuildSubmission(ctx context.Context, in *LabRequest, opts ...grpc.CallOption) (*Void, error)
	GetCourseLabSubmissions(ctx context.Context, in *LabRequest, opts ...grpc.CallOption) (*LabResultLinks, error)
	GetProviders(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Providers, error)
	GetOrganization(ctx context.Context, in *OrgRequest, opts ...grpc.CallOption) (*Organization, error)
	GetRepositories(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*Repositories, error)
	IsEmptyRepo(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*Void, error)
}

type autograderServiceClient struct {
	cc *grpc.ClientConn
}

func NewAutograderServiceClient(cc *grpc.ClientConn) AutograderServiceClient {
	return &autograderServiceClient{cc}
}

func (c *autograderServiceClient) GetUser(ctx context.Context, in *Void, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/AutograderService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetUsers(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Users, error) {
	out := new(Users)
	err := c.cc.Invoke(ctx, "/AutograderService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) IsAuthorizedTeacher(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AuthorizationResponse, error) {
	out := new(AuthorizationResponse)
	err := c.cc.Invoke(ctx, "/AutograderService/IsAuthorizedTeacher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroupByUserAndCourse(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroupByUserAndCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroups(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Groups, error) {
	out := new(Groups)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/DeleteGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourse(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Course, error) {
	out := new(Course)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourses(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Courses, error) {
	out := new(Courses)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCoursesWithEnrollment(ctx context.Context, in *CoursesListRequest, opts ...grpc.CallOption) (*Courses, error) {
	out := new(Courses)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCoursesWithEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Course, error) {
	out := new(Course)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetAssignments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Assignments, error) {
	out := new(Assignments)
	err := c.cc.Invoke(ctx, "/AutograderService/GetAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateAssignments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetEnrollmentsByCourse(ctx context.Context, in *EnrollmentRequest, opts ...grpc.CallOption) (*Enrollments, error) {
	out := new(Enrollments)
	err := c.cc.Invoke(ctx, "/AutograderService/GetEnrollmentsByCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateEnrollment(ctx context.Context, in *Enrollment, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateEnrollment(ctx context.Context, in *Enrollment, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateEnrollments(ctx context.Context, in *CourseRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateEnrollments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetSubmissions(ctx context.Context, in *SubmissionRequest, opts ...grpc.CallOption) (*Submissions, error) {
	out := new(Submissions)
	err := c.cc.Invoke(ctx, "/AutograderService/GetSubmissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) ApproveSubmission(ctx context.Context, in *ApproveSubmissionRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/ApproveSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) RebuildSubmission(ctx context.Context, in *LabRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/RebuildSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourseLabSubmissions(ctx context.Context, in *LabRequest, opts ...grpc.CallOption) (*LabResultLinks, error) {
	out := new(LabResultLinks)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourseLabSubmissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetProviders(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Providers, error) {
	out := new(Providers)
	err := c.cc.Invoke(ctx, "/AutograderService/GetProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetOrganization(ctx context.Context, in *OrgRequest, opts ...grpc.CallOption) (*Organization, error) {
	out := new(Organization)
	err := c.cc.Invoke(ctx, "/AutograderService/GetOrganization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetRepositories(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*Repositories, error) {
	out := new(Repositories)
	err := c.cc.Invoke(ctx, "/AutograderService/GetRepositories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) IsEmptyRepo(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/IsEmptyRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutograderServiceServer is the server API for AutograderService service.
type AutograderServiceServer interface {
	GetUser(context.Context, *Void) (*User, error)
	GetUsers(context.Context, *Void) (*Users, error)
	UpdateUser(context.Context, *User) (*User, error)
	IsAuthorizedTeacher(context.Context, *Void) (*AuthorizationResponse, error)
	GetGroup(context.Context, *GetGroupRequest) (*Group, error)
	GetGroupByUserAndCourse(context.Context, *GroupRequest) (*Group, error)
	GetGroups(context.Context, *CourseRequest) (*Groups, error)
	CreateGroup(context.Context, *Group) (*Group, error)
	UpdateGroup(context.Context, *Group) (*Void, error)
	DeleteGroup(context.Context, *GroupRequest) (*Void, error)
	GetCourse(context.Context, *CourseRequest) (*Course, error)
	GetCourses(context.Context, *Void) (*Courses, error)
	GetCoursesWithEnrollment(context.Context, *CoursesListRequest) (*Courses, error)
	CreateCourse(context.Context, *Course) (*Course, error)
	UpdateCourse(context.Context, *Course) (*Void, error)
	GetAssignments(context.Context, *CourseRequest) (*Assignments, error)
	UpdateAssignments(context.Context, *CourseRequest) (*Void, error)
	GetEnrollmentsByCourse(context.Context, *EnrollmentRequest) (*Enrollments, error)
	CreateEnrollment(context.Context, *Enrollment) (*Void, error)
	UpdateEnrollment(context.Context, *Enrollment) (*Void, error)
	UpdateEnrollments(context.Context, *CourseRequest) (*Void, error)
	GetSubmissions(context.Context, *SubmissionRequest) (*Submissions, error)
	ApproveSubmission(context.Context, *ApproveSubmissionRequest) (*Void, error)
	RebuildSubmission(context.Context, *LabRequest) (*Void, error)
	GetCourseLabSubmissions(context.Context, *LabRequest) (*LabResultLinks, error)
	GetProviders(context.Context, *Void) (*Providers, error)
	GetOrganization(context.Context, *OrgRequest) (*Organization, error)
	GetRepositories(context.Context, *URLRequest) (*Repositories, error)
	IsEmptyRepo(context.Context, *RepositoryRequest) (*Void, error)
}

func RegisterAutograderServiceServer(s *grpc.Server, srv AutograderServiceServer) {
	s.RegisterService(&_AutograderService_serviceDesc, srv)
}

func _AutograderService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetUser(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetUsers(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_IsAuthorizedTeacher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).IsAuthorizedTeacher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/IsAuthorizedTeacher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).IsAuthorizedTeacher(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroup(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroupByUserAndCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroupByUserAndCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroupByUserAndCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroupByUserAndCourse(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroups(ctx, req.(*CourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).DeleteGroup(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourse(ctx, req.(*CourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourses(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCoursesWithEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoursesListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCoursesWithEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCoursesWithEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCoursesWithEnrollment(ctx, req.(*CoursesListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Course)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateCourse(ctx, req.(*Course))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Course)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateCourse(ctx, req.(*Course))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetAssignments(ctx, req.(*CourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateAssignments(ctx, req.(*CourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetEnrollmentsByCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnrollmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetEnrollmentsByCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetEnrollmentsByCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetEnrollmentsByCourse(ctx, req.(*EnrollmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Enrollment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateEnrollment(ctx, req.(*Enrollment))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Enrollment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateEnrollment(ctx, req.(*Enrollment))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateEnrollments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateEnrollments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateEnrollments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateEnrollments(ctx, req.(*CourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetSubmissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetSubmissions(ctx, req.(*SubmissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_ApproveSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveSubmissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).ApproveSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/ApproveSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).ApproveSubmission(ctx, req.(*ApproveSubmissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_RebuildSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).RebuildSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/RebuildSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).RebuildSubmission(ctx, req.(*LabRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourseLabSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourseLabSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourseLabSubmissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourseLabSubmissions(ctx, req.(*LabRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetProviders(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetOrganization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetOrganization(ctx, req.(*OrgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetRepositories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(URLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetRepositories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetRepositories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetRepositories(ctx, req.(*URLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_IsEmptyRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).IsEmptyRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/IsEmptyRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).IsEmptyRepo(ctx, req.(*RepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutograderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "AutograderService",
	HandlerType: (*AutograderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _AutograderService_GetUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _AutograderService_GetUsers_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _AutograderService_UpdateUser_Handler,
		},
		{
			MethodName: "IsAuthorizedTeacher",
			Handler:    _AutograderService_IsAuthorizedTeacher_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _AutograderService_GetGroup_Handler,
		},
		{
			MethodName: "GetGroupByUserAndCourse",
			Handler:    _AutograderService_GetGroupByUserAndCourse_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _AutograderService_GetGroups_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _AutograderService_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _AutograderService_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _AutograderService_DeleteGroup_Handler,
		},
		{
			MethodName: "GetCourse",
			Handler:    _AutograderService_GetCourse_Handler,
		},
		{
			MethodName: "GetCourses",
			Handler:    _AutograderService_GetCourses_Handler,
		},
		{
			MethodName: "GetCoursesWithEnrollment",
			Handler:    _AutograderService_GetCoursesWithEnrollment_Handler,
		},
		{
			MethodName: "CreateCourse",
			Handler:    _AutograderService_CreateCourse_Handler,
		},
		{
			MethodName: "UpdateCourse",
			Handler:    _AutograderService_UpdateCourse_Handler,
		},
		{
			MethodName: "GetAssignments",
			Handler:    _AutograderService_GetAssignments_Handler,
		},
		{
			MethodName: "UpdateAssignments",
			Handler:    _AutograderService_UpdateAssignments_Handler,
		},
		{
			MethodName: "GetEnrollmentsByCourse",
			Handler:    _AutograderService_GetEnrollmentsByCourse_Handler,
		},
		{
			MethodName: "CreateEnrollment",
			Handler:    _AutograderService_CreateEnrollment_Handler,
		},
		{
			MethodName: "UpdateEnrollment",
			Handler:    _AutograderService_UpdateEnrollment_Handler,
		},
		{
			MethodName: "UpdateEnrollments",
			Handler:    _AutograderService_UpdateEnrollments_Handler,
		},
		{
			MethodName: "GetSubmissions",
			Handler:    _AutograderService_GetSubmissions_Handler,
		},
		{
			MethodName: "ApproveSubmission",
			Handler:    _AutograderService_ApproveSubmission_Handler,
		},
		{
			MethodName: "RebuildSubmission",
			Handler:    _AutograderService_RebuildSubmission_Handler,
		},
		{
			MethodName: "GetCourseLabSubmissions",
			Handler:    _AutograderService_GetCourseLabSubmissions_Handler,
		},
		{
			MethodName: "GetProviders",
			Handler:    _AutograderService_GetProviders_Handler,
		},
		{
			MethodName: "GetOrganization",
			Handler:    _AutograderService_GetOrganization_Handler,
		},
		{
			MethodName: "GetRepositories",
			Handler:    _AutograderService_GetRepositories_Handler,
		},
		{
			MethodName: "IsEmptyRepo",
			Handler:    _AutograderService_IsEmptyRepo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ag.proto",
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.IsAdmin {
		dAtA[i] = 0x10
		i++
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.StudentID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.StudentID)))
		i += copy(dAtA[i:], m.StudentID)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.AvatarURL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AvatarURL)))
		i += copy(dAtA[i:], m.AvatarURL)
	}
	if len(m.Login) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Login)))
		i += copy(dAtA[i:], m.Login)
	}
	if len(m.RemoteIdentities) > 0 {
		for _, msg := range m.RemoteIdentities {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Users) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Users) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIdentity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.RemoteID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RemoteID))
	}
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if m.UserID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.TeamID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.TeamID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Groups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Groups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Course) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Course) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseCreatorID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseCreatorID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Year != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Year))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.OrganizationID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.OrganizationID))
	}
	if m.Enrolled != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x52
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0x62
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Courses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Courses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, msg := range m.Courses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Repository) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repository) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.OrganizationID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.OrganizationID))
	}
	if m.RepositoryID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if len(m.HTMLURL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.HTMLURL)))
		i += copy(dAtA[i:], m.HTMLURL)
	}
	if m.RepoType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepoType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Organization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Organization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if len(m.PaymentPlan) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.PaymentPlan)))
		i += copy(dAtA[i:], m.PaymentPlan)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Organizations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Organizations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Organizations) > 0 {
		for _, msg := range m.Organizations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Enrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Course != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course.Size()))
		n2, err := m.Course.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Group != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group.Size()))
		n3, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Enrollments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Assignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Deadline) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Deadline)))
		i += copy(dAtA[i:], m.Deadline)
	}
	if m.AutoApprove {
		dAtA[i] = 0x30
		i++
		if m.AutoApprove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Order != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Order))
	}
	if m.IsGroupLab {
		dAtA[i] = 0x40
		i++
		if m.IsGroupLab {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Submission != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Submission.Size()))
		n4, err := m.Submission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Assignments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Submission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.AssignmentID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.AssignmentID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Score))
	}
	if len(m.ScoreObjects) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.ScoreObjects)))
		i += copy(dAtA[i:], m.ScoreObjects)
	}
	if len(m.BuildInfo) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.BuildInfo)))
		i += copy(dAtA[i:], m.BuildInfo)
	}
	if len(m.CommitHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.CommitHash)))
		i += copy(dAtA[i:], m.CommitHash)
	}
	if m.Approved {
		dAtA[i] = 0x48
		i++
		if m.Approved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Submissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, msg := range m.Submissions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LabResultLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabResultLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthorName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AuthorName)))
		i += copy(dAtA[i:], m.AuthorName)
	}
	if m.Enrollment != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Enrollment.Size()))
		n5, err := m.Enrollment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Submissions) > 0 {
		for _, msg := range m.Submissions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LabResultLinks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabResultLinks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labs) > 0 {
		for _, msg := range m.Labs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CourseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CourseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CourseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CoursesListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoursesListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if len(m.States) > 0 {
		dAtA7 := make([]byte, len(m.States)*10)
		var j6 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Provider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Provider) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrgRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrgRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrgName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.OrgName)))
		i += copy(dAtA[i:], m.OrgName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnrollmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrollmentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CourseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.FilterOutGroupMembers {
		dAtA[i] = 0x10
		i++
		if m.FilterOutGroupMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.States) > 0 {
		dAtA9 := make([]byte, len(m.States)*10)
		var j8 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ApproveSubmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApproveSubmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubmissionID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.SubmissionID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Providers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Providers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *URLRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CourseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if len(m.RepoTypes) > 0 {
		dAtA11 := make([]byte, len(m.RepoTypes)*10)
		var j10 int
		for _, num := range m.RepoTypes {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepositoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepositoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Repositories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repositories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URLs) > 0 {
		for k, _ := range m.URLs {
			dAtA[i] = 0xa
			i++
			v := m.URLs[k]
			mapSize := 1 + len(k) + sovAg(uint64(len(k))) + 1 + len(v) + sovAg(uint64(len(v)))
			i = encodeVarintAg(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAg(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthorizationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsAuthorized {
		dAtA[i] = 0x8
		i++
		if m.IsAuthorized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Code))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LabRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CourseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.SubmissionID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.SubmissionID))
	}
	if m.AssignmentID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.AssignmentID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAg(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.IsAdmin {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.StudentID)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if len(m.RemoteIdentities) > 0 {
		for _, e := range m.RemoteIdentities {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Users) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.RemoteID != 0 {
		n += 1 + sovAg(uint64(m.RemoteID))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.TeamID != 0 {
		n += 1 + sovAg(uint64(m.TeamID))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Groups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Course) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseCreatorID != 0 {
		n += 1 + sovAg(uint64(m.CourseCreatorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Year != 0 {
		n += 1 + sovAg(uint64(m.Year))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.OrganizationID != 0 {
		n += 1 + sovAg(uint64(m.OrganizationID))
	}
	if m.Enrolled != 0 {
		n += 1 + sovAg(uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Courses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, e := range m.Courses {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Repository) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.OrganizationID != 0 {
		n += 1 + sovAg(uint64(m.OrganizationID))
	}
	if m.RepositoryID != 0 {
		n += 1 + sovAg(uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	l = len(m.HTMLURL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.RepoType != 0 {
		n += 1 + sovAg(uint64(m.RepoType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Organization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.PaymentPlan)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Organizations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Organizations) > 0 {
		for _, e := range m.Organizations {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Enrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Course != nil {
		l = m.Course.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Enrollments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Assignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Deadline)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.AutoApprove {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovAg(uint64(m.Order))
	}
	if m.IsGroupLab {
		n += 2
	}
	if m.Submission != nil {
		l = m.Submission.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Assignments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Submission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.AssignmentID != 0 {
		n += 1 + sovAg(uint64(m.AssignmentID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.Score != 0 {
		n += 1 + sovAg(uint64(m.Score))
	}
	l = len(m.ScoreObjects)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.BuildInfo)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.CommitHash)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Approved {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Submissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, e := range m.Submissions {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabResultLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthorName)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Enrollment != nil {
		l = m.Enrollment.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if len(m.Submissions) > 0 {
		for _, e := range m.Submissions {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabResultLinks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labs) > 0 {
		for _, e := range m.Labs {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CourseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CoursesListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Provider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrgRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnrollmentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.FilterOutGroupMembers {
		n += 2
	}
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApproveSubmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmissionID != 0 {
		n += 1 + sovAg(uint64(m.SubmissionID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Providers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			l = len(s)
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *URLRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if len(m.RepoTypes) > 0 {
		l = 0
		for _, e := range m.RepoTypes {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepositoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Repositories) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.URLs) > 0 {
		for k, v := range m.URLs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAg(uint64(len(k))) + 1 + len(v) + sovAg(uint64(len(v)))
			n += mapEntrySize + 1 + sovAg(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthorizationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsAuthorized {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAg(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.SubmissionID != 0 {
		n += 1 + sovAg(uint64(m.SubmissionID))
	}
	if m.AssignmentID != 0 {
		n += 1 + sovAg(uint64(m.AssignmentID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAg(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAg(x uint64) (n int) {
	return sovAg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIdentities = append(m.RemoteIdentities, &RemoteIdentity{})
			if err := m.RemoteIdentities[len(m.RemoteIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Users) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Users: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Users: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteID", wireType)
			}
			m.RemoteID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Group_GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Groups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Groups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Groups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Course) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Course: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Course: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseCreatorID", wireType)
			}
			m.CourseCreatorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseCreatorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Year |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationID", wireType)
			}
			m.OrganizationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrganizationID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrolled", wireType)
			}
			m.Enrolled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enrolled |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Courses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Courses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Courses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Courses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Courses = append(m.Courses, &Course{})
			if err := m.Courses[len(m.Courses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repository) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repository: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repository: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationID", wireType)
			}
			m.OrganizationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrganizationID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepositoryID", wireType)
			}
			m.RepositoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepositoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTMLURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTMLURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoType", wireType)
			}
			m.RepoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepoType |= Repository_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Organization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Organization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Organization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Organizations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Organizations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Organizations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organizations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organizations = append(m.Organizations, &Organization{})
			if err := m.Organizations[len(m.Organizations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Course == nil {
				m.Course = &Course{}
			}
			if err := m.Course.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deadline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApprove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApprove = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGroupLab", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGroupLab = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Submission == nil {
				m.Submission = &Submission{}
			}
			if err := m.Submission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignmentID", wireType)
			}
			m.AssignmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreObjects", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScoreObjects = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submissions = append(m.Submissions, &Submission{})
			if err := m.Submissions[len(m.Submissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabResultLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabResultLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabResultLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enrollment == nil {
				m.Enrollment = &Enrollment{}
			}
			if err := m.Enrollment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submissions = append(m.Submissions, &Submission{})
			if err := m.Submissions[len(m.Submissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabResultLinks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabResultLinks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabResultLinks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labs = append(m.Labs, &LabResultLink{})
			if err := m.Labs[len(m.Labs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CourseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CourseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CourseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoursesListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoursesListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoursesListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Enrollment_UserStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Enrollment_UserStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]Enrollment_UserStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Enrollment_UserStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Enrollment_UserStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Provider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrollmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrollmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrollmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterOutGroupMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterOutGroupMembers = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v Enrollment_UserStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Enrollment_UserStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]Enrollment_UserStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Enrollment_UserStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Enrollment_UserStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApproveSubmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApproveSubmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApproveSubmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionID", wireType)
			}
			m.SubmissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Providers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Providers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Providers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Repository_Type
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Repository_Type(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepoTypes = append(m.RepoTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepoTypes) == 0 {
					m.RepoTypes = make([]Repository_Type, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Repository_Type
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Repository_Type(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepoTypes = append(m.RepoTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepositoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepositoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepositoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repositories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repositories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repositories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URLs == nil {
				m.URLs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAg
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAg
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAg
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAg
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URLs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAuthorized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAuthorized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionID", wireType)
			}
			m.SubmissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignmentID", wireType)
			}
			m.AssignmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAg
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAg
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAg
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAg(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAg
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAg = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAg   = fmt.Errorf("proto: integer overflow")
)
