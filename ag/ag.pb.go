// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ag.proto

package ag

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Group_GroupStatus int32

const (
	Group_PENDING  Group_GroupStatus = 0
	Group_REJECTED Group_GroupStatus = 1
	Group_APPROVED Group_GroupStatus = 2
	Group_DELETED  Group_GroupStatus = 3
)

var Group_GroupStatus_name = map[int32]string{
	0: "PENDING",
	1: "REJECTED",
	2: "APPROVED",
	3: "DELETED",
}

var Group_GroupStatus_value = map[string]int32{
	"PENDING":  0,
	"REJECTED": 1,
	"APPROVED": 2,
	"DELETED":  3,
}

func (x Group_GroupStatus) String() string {
	return proto.EnumName(Group_GroupStatus_name, int32(x))
}

func (Group_GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3, 0}
}

type Enrollment_UserStatus int32

const (
	Enrollment_NONE     Enrollment_UserStatus = 0
	Enrollment_PENDING  Enrollment_UserStatus = 1
	Enrollment_REJECTED Enrollment_UserStatus = 2
	Enrollment_STUDENT  Enrollment_UserStatus = 3
	Enrollment_TEACHER  Enrollment_UserStatus = 4
)

var Enrollment_UserStatus_name = map[int32]string{
	0: "NONE",
	1: "PENDING",
	2: "REJECTED",
	3: "STUDENT",
	4: "TEACHER",
}

var Enrollment_UserStatus_value = map[string]int32{
	"NONE":     0,
	"PENDING":  1,
	"REJECTED": 2,
	"STUDENT":  3,
	"TEACHER":  4,
}

func (x Enrollment_UserStatus) String() string {
	return proto.EnumName(Enrollment_UserStatus_name, int32(x))
}

func (Enrollment_UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7, 0}
}

type Repository_Type int32

const (
	Repository_USER        Repository_Type = 0
	Repository_ASSIGNMENTS Repository_Type = 1
	Repository_TESTS       Repository_Type = 2
	Repository_SOLUTIONS   Repository_Type = 3
	Repository_COURSEINFO  Repository_Type = 4
)

var Repository_Type_name = map[int32]string{
	0: "USER",
	1: "ASSIGNMENTS",
	2: "TESTS",
	3: "SOLUTIONS",
	4: "COURSEINFO",
}

var Repository_Type_value = map[string]int32{
	"USER":        0,
	"ASSIGNMENTS": 1,
	"TESTS":       2,
	"SOLUTIONS":   3,
	"COURSEINFO":  4,
}

func (x Repository_Type) String() string {
	return proto.EnumName(Repository_Type_name, int32(x))
}

func (Repository_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{13, 0}
}

type User struct {
	ID                   uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	IsAdmin              bool              `protobuf:"varint,2,opt,name=isAdmin,proto3" json:"isAdmin,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	StudentID            string            `protobuf:"bytes,4,opt,name=studentID,proto3" json:"studentID,omitempty"`
	Email                string            `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	AvatarURL            string            `protobuf:"bytes,6,opt,name=avatarURL,proto3" json:"avatarURL,omitempty"`
	Login                string            `protobuf:"bytes,7,opt,name=login,proto3" json:"login,omitempty"`
	RemoteIdentities     []*RemoteIdentity `protobuf:"bytes,8,rep,name=remoteIdentities,proto3" json:"remoteIdentities,omitempty"`
	Enrollments          []*Enrollment     `protobuf:"bytes,9,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{0}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetStudentID() string {
	if m != nil {
		return m.StudentID
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetAvatarURL() string {
	if m != nil {
		return m.AvatarURL
	}
	return ""
}

func (m *User) GetLogin() string {
	if m != nil {
		return m.Login
	}
	return ""
}

func (m *User) GetRemoteIdentities() []*RemoteIdentity {
	if m != nil {
		return m.RemoteIdentities
	}
	return nil
}

func (m *User) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Users struct {
	Users                []*User  `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Users) Reset()         { *m = Users{} }
func (m *Users) String() string { return proto.CompactTextString(m) }
func (*Users) ProtoMessage()    {}
func (*Users) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{1}
}
func (m *Users) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Users) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Users.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Users) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Users.Merge(m, src)
}
func (m *Users) XXX_Size() int {
	return m.Size()
}
func (m *Users) XXX_DiscardUnknown() {
	xxx_messageInfo_Users.DiscardUnknown(m)
}

var xxx_messageInfo_Users proto.InternalMessageInfo

func (m *Users) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type RemoteIdentity struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Provider             string   `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	RemoteID             uint64   `protobuf:"varint,3,opt,name=remoteID,proto3" json:"remoteID,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	AccessToken          string   `protobuf:"bytes,4,opt,name=accessToken,proto3" json:"accessToken,omitempty"`
	UserID               uint64   `protobuf:"varint,5,opt,name=userID,proto3" json:"userID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteIdentity) Reset()         { *m = RemoteIdentity{} }
func (m *RemoteIdentity) String() string { return proto.CompactTextString(m) }
func (*RemoteIdentity) ProtoMessage()    {}
func (*RemoteIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{2}
}
func (m *RemoteIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteIdentity.Merge(m, src)
}
func (m *RemoteIdentity) XXX_Size() int {
	return m.Size()
}
func (m *RemoteIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteIdentity proto.InternalMessageInfo

func (m *RemoteIdentity) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoteIdentity) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *RemoteIdentity) GetRemoteID() uint64 {
	if m != nil {
		return m.RemoteID
	}
	return 0
}

func (m *RemoteIdentity) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *RemoteIdentity) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type Group struct {
	ID                   uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" gorm:"unique_index:idx_unique_group_name"`
	CourseID             uint64            `protobuf:"varint,3,opt,name=courseID,proto3" json:"courseID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	TeamID               uint64            `protobuf:"varint,4,opt,name=teamID,proto3" json:"teamID,omitempty"`
	Status               Group_GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=Group_GroupStatus" json:"status,omitempty"`
	Users                []*User           `protobuf:"bytes,6,rep,name=users,proto3" json:"users,omitempty"`
	Enrollments          []*Enrollment     `protobuf:"bytes,7,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Group) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Group) GetTeamID() uint64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *Group) GetStatus() Group_GroupStatus {
	if m != nil {
		return m.Status
	}
	return Group_PENDING
}

func (m *Group) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Group) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Groups struct {
	Groups               []*Group `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Groups) Reset()         { *m = Groups{} }
func (m *Groups) String() string { return proto.CompactTextString(m) }
func (*Groups) ProtoMessage()    {}
func (*Groups) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{4}
}
func (m *Groups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Groups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Groups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Groups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Groups.Merge(m, src)
}
func (m *Groups) XXX_Size() int {
	return m.Size()
}
func (m *Groups) XXX_DiscardUnknown() {
	xxx_messageInfo_Groups.DiscardUnknown(m)
}

var xxx_messageInfo_Groups proto.InternalMessageInfo

func (m *Groups) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Course struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseCreatorID      uint64                `protobuf:"varint,2,opt,name=courseCreatorID,proto3" json:"courseCreatorID,omitempty"`
	Name                 string                `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Code                 string                `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Year                 uint32                `protobuf:"varint,5,opt,name=year,proto3" json:"year,omitempty"`
	Tag                  string                `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
	Provider             string                `protobuf:"bytes,7,opt,name=provider,proto3" json:"provider,omitempty"`
	DirectoryID          uint64                `protobuf:"varint,8,opt,name=directoryID,proto3" json:"directoryID,omitempty"`
	Enrolled             Enrollment_UserStatus `protobuf:"varint,9,opt,name=enrolled,proto3,enum=Enrollment_UserStatus" json:"enrolled,omitempty"`
	Enrollments          []*Enrollment         `protobuf:"bytes,10,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	Assignments          []*Assignment         `protobuf:"bytes,12,rep,name=assignments,proto3" json:"assignments,omitempty"`
	Groups               []*Group              `protobuf:"bytes,13,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Course) Reset()         { *m = Course{} }
func (m *Course) String() string { return proto.CompactTextString(m) }
func (*Course) ProtoMessage()    {}
func (*Course) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{5}
}
func (m *Course) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Course) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Course.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Course) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Course.Merge(m, src)
}
func (m *Course) XXX_Size() int {
	return m.Size()
}
func (m *Course) XXX_DiscardUnknown() {
	xxx_messageInfo_Course.DiscardUnknown(m)
}

var xxx_messageInfo_Course proto.InternalMessageInfo

func (m *Course) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Course) GetCourseCreatorID() uint64 {
	if m != nil {
		return m.CourseCreatorID
	}
	return 0
}

func (m *Course) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Course) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Course) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *Course) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Course) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Course) GetDirectoryID() uint64 {
	if m != nil {
		return m.DirectoryID
	}
	return 0
}

func (m *Course) GetEnrolled() Enrollment_UserStatus {
	if m != nil {
		return m.Enrolled
	}
	return Enrollment_NONE
}

func (m *Course) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

func (m *Course) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

func (m *Course) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Courses struct {
	Courses              []*Course `protobuf:"bytes,1,rep,name=courses,proto3" json:"courses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Courses) Reset()         { *m = Courses{} }
func (m *Courses) String() string { return proto.CompactTextString(m) }
func (*Courses) ProtoMessage()    {}
func (*Courses) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{6}
}
func (m *Courses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Courses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Courses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Courses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Courses.Merge(m, src)
}
func (m *Courses) XXX_Size() int {
	return m.Size()
}
func (m *Courses) XXX_DiscardUnknown() {
	xxx_messageInfo_Courses.DiscardUnknown(m)
}

var xxx_messageInfo_Courses proto.InternalMessageInfo

func (m *Courses) GetCourses() []*Course {
	if m != nil {
		return m.Courses
	}
	return nil
}

type Enrollment struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseID             uint64                `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	UserID               uint64                `protobuf:"varint,3,opt,name=userID,proto3" json:"userID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	GroupID              uint64                `protobuf:"varint,4,opt,name=groupID,proto3" json:"groupID,omitempty"`
	User                 *User                 `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
	Course               *Course               `protobuf:"bytes,6,opt,name=course,proto3" json:"course,omitempty"`
	Group                *Group                `protobuf:"bytes,7,opt,name=group,proto3" json:"group,omitempty"`
	Status               Enrollment_UserStatus `protobuf:"varint,8,opt,name=status,proto3,enum=Enrollment_UserStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Enrollment) Reset()         { *m = Enrollment{} }
func (m *Enrollment) String() string { return proto.CompactTextString(m) }
func (*Enrollment) ProtoMessage()    {}
func (*Enrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7}
}
func (m *Enrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollment.Merge(m, src)
}
func (m *Enrollment) XXX_Size() int {
	return m.Size()
}
func (m *Enrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollment.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollment proto.InternalMessageInfo

func (m *Enrollment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Enrollment) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Enrollment) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Enrollment) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Enrollment) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Enrollment) GetCourse() *Course {
	if m != nil {
		return m.Course
	}
	return nil
}

func (m *Enrollment) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Enrollment) GetStatus() Enrollment_UserStatus {
	if m != nil {
		return m.Status
	}
	return Enrollment_NONE
}

type Enrollments struct {
	Enrollments          []*Enrollment `protobuf:"bytes,1,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Enrollments) Reset()         { *m = Enrollments{} }
func (m *Enrollments) String() string { return proto.CompactTextString(m) }
func (*Enrollments) ProtoMessage()    {}
func (*Enrollments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{8}
}
func (m *Enrollments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollments.Merge(m, src)
}
func (m *Enrollments) XXX_Size() int {
	return m.Size()
}
func (m *Enrollments) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollments.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollments proto.InternalMessageInfo

func (m *Enrollments) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Assignment struct {
	ID                   uint64           `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseID             uint64           `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty"`
	Name                 string           `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Language             string           `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Deadline             *types.Timestamp `protobuf:"bytes,5,opt,name=deadline,proto3" json:"deadline,omitempty"`
	AutoApprove          bool             `protobuf:"varint,6,opt,name=autoApprove,proto3" json:"autoApprove,omitempty"`
	Order                uint32           `protobuf:"varint,7,opt,name=order,proto3" json:"order,omitempty"`
	IsGroupLab           bool             `protobuf:"varint,8,opt,name=isGroupLab,proto3" json:"isGroupLab,omitempty"`
	Submission           *Submission      `protobuf:"bytes,9,opt,name=submission,proto3" json:"submission,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Assignment) Reset()         { *m = Assignment{} }
func (m *Assignment) String() string { return proto.CompactTextString(m) }
func (*Assignment) ProtoMessage()    {}
func (*Assignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{9}
}
func (m *Assignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignment.Merge(m, src)
}
func (m *Assignment) XXX_Size() int {
	return m.Size()
}
func (m *Assignment) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignment.DiscardUnknown(m)
}

var xxx_messageInfo_Assignment proto.InternalMessageInfo

func (m *Assignment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Assignment) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *Assignment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Assignment) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Assignment) GetDeadline() *types.Timestamp {
	if m != nil {
		return m.Deadline
	}
	return nil
}

func (m *Assignment) GetAutoApprove() bool {
	if m != nil {
		return m.AutoApprove
	}
	return false
}

func (m *Assignment) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *Assignment) GetIsGroupLab() bool {
	if m != nil {
		return m.IsGroupLab
	}
	return false
}

func (m *Assignment) GetSubmission() *Submission {
	if m != nil {
		return m.Submission
	}
	return nil
}

type Assignments struct {
	Assignments          []*Assignment `protobuf:"bytes,1,rep,name=assignments,proto3" json:"assignments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Assignments) Reset()         { *m = Assignments{} }
func (m *Assignments) String() string { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()    {}
func (*Assignments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{10}
}
func (m *Assignments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignments.Merge(m, src)
}
func (m *Assignments) XXX_Size() int {
	return m.Size()
}
func (m *Assignments) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignments.DiscardUnknown(m)
}

var xxx_messageInfo_Assignments proto.InternalMessageInfo

func (m *Assignments) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

type Submission struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	AssignmentID         uint64   `protobuf:"varint,2,opt,name=assignmentID,proto3" json:"assignmentID,omitempty"`
	UserID               uint64   `protobuf:"varint,3,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64   `protobuf:"varint,4,opt,name=groupID,proto3" json:"groupID,omitempty"`
	Score                uint32   `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
	ScoreObjects         string   `protobuf:"bytes,6,opt,name=scoreObjects,proto3" json:"scoreObjects,omitempty"`
	BuildInfo            string   `protobuf:"bytes,7,opt,name=buildInfo,proto3" json:"buildInfo,omitempty"`
	CommitHash           string   `protobuf:"bytes,8,opt,name=commitHash,proto3" json:"commitHash,omitempty"`
	Approved             bool     `protobuf:"varint,9,opt,name=approved,proto3" json:"approved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Submission) Reset()         { *m = Submission{} }
func (m *Submission) String() string { return proto.CompactTextString(m) }
func (*Submission) ProtoMessage()    {}
func (*Submission) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{11}
}
func (m *Submission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submission.Merge(m, src)
}
func (m *Submission) XXX_Size() int {
	return m.Size()
}
func (m *Submission) XXX_DiscardUnknown() {
	xxx_messageInfo_Submission.DiscardUnknown(m)
}

var xxx_messageInfo_Submission proto.InternalMessageInfo

func (m *Submission) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Submission) GetAssignmentID() uint64 {
	if m != nil {
		return m.AssignmentID
	}
	return 0
}

func (m *Submission) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Submission) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Submission) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Submission) GetScoreObjects() string {
	if m != nil {
		return m.ScoreObjects
	}
	return ""
}

func (m *Submission) GetBuildInfo() string {
	if m != nil {
		return m.BuildInfo
	}
	return ""
}

func (m *Submission) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Submission) GetApproved() bool {
	if m != nil {
		return m.Approved
	}
	return false
}

type Submissions struct {
	Submissions          []*Submission `protobuf:"bytes,1,rep,name=submissions,proto3" json:"submissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Submissions) Reset()         { *m = Submissions{} }
func (m *Submissions) String() string { return proto.CompactTextString(m) }
func (*Submissions) ProtoMessage()    {}
func (*Submissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{12}
}
func (m *Submissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submissions.Merge(m, src)
}
func (m *Submissions) XXX_Size() int {
	return m.Size()
}
func (m *Submissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Submissions.DiscardUnknown(m)
}

var xxx_messageInfo_Submissions proto.InternalMessageInfo

func (m *Submissions) GetSubmissions() []*Submission {
	if m != nil {
		return m.Submissions
	}
	return nil
}

type Repository struct {
	ID                   uint64          `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	DirectoryID          uint64          `protobuf:"varint,2,opt,name=directoryID,proto3" json:"directoryID,omitempty"`
	RepositoryID         uint64          `protobuf:"varint,3,opt,name=repositoryID,proto3" json:"repositoryID,omitempty"`
	UserID               uint64          `protobuf:"varint,4,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64          `protobuf:"varint,5,opt,name=groupID,proto3" json:"groupID,omitempty"`
	HTMLURL              string          `protobuf:"bytes,6,opt,name=HTMLURL,proto3" json:"HTMLURL,omitempty"`
	RepoType             Repository_Type `protobuf:"varint,7,opt,name=repoType,proto3,enum=Repository_Type" json:"repoType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Repository) Reset()         { *m = Repository{} }
func (m *Repository) String() string { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()    {}
func (*Repository) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{13}
}
func (m *Repository) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repository.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repository.Merge(m, src)
}
func (m *Repository) XXX_Size() int {
	return m.Size()
}
func (m *Repository) XXX_DiscardUnknown() {
	xxx_messageInfo_Repository.DiscardUnknown(m)
}

var xxx_messageInfo_Repository proto.InternalMessageInfo

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetDirectoryID() uint64 {
	if m != nil {
		return m.DirectoryID
	}
	return 0
}

func (m *Repository) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Repository) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Repository) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Repository) GetHTMLURL() string {
	if m != nil {
		return m.HTMLURL
	}
	return ""
}

func (m *Repository) GetRepoType() Repository_Type {
	if m != nil {
		return m.RepoType
	}
	return Repository_USER
}

type Repositories struct {
	Repositories         []*Repository `protobuf:"bytes,1,rep,name=repositories,proto3" json:"repositories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Repositories) Reset()         { *m = Repositories{} }
func (m *Repositories) String() string { return proto.CompactTextString(m) }
func (*Repositories) ProtoMessage()    {}
func (*Repositories) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{14}
}
func (m *Repositories) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repositories) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repositories.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repositories) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repositories.Merge(m, src)
}
func (m *Repositories) XXX_Size() int {
	return m.Size()
}
func (m *Repositories) XXX_DiscardUnknown() {
	xxx_messageInfo_Repositories.DiscardUnknown(m)
}

var xxx_messageInfo_Repositories proto.InternalMessageInfo

func (m *Repositories) GetRepositories() []*Repository {
	if m != nil {
		return m.Repositories
	}
	return nil
}

type Directory struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Avatar               string   `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Directory) Reset()         { *m = Directory{} }
func (m *Directory) String() string { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()    {}
func (*Directory) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{15}
}
func (m *Directory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Directory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Directory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Directory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Directory.Merge(m, src)
}
func (m *Directory) XXX_Size() int {
	return m.Size()
}
func (m *Directory) XXX_DiscardUnknown() {
	xxx_messageInfo_Directory.DiscardUnknown(m)
}

var xxx_messageInfo_Directory proto.InternalMessageInfo

func (m *Directory) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Directory) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Directory) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

type Directories struct {
	Directories          []*Directory `protobuf:"bytes,1,rep,name=directories,proto3" json:"directories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Directories) Reset()         { *m = Directories{} }
func (m *Directories) String() string { return proto.CompactTextString(m) }
func (*Directories) ProtoMessage()    {}
func (*Directories) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{16}
}
func (m *Directories) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Directories) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Directories.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Directories) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Directories.Merge(m, src)
}
func (m *Directories) XXX_Size() int {
	return m.Size()
}
func (m *Directories) XXX_DiscardUnknown() {
	xxx_messageInfo_Directories.DiscardUnknown(m)
}

var xxx_messageInfo_Directories proto.InternalMessageInfo

func (m *Directories) GetDirectories() []*Directory {
	if m != nil {
		return m.Directories
	}
	return nil
}

type RecordRequest struct {
	ID                   uint64                  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Statuses             []Enrollment_UserStatus `protobuf:"varint,2,rep,packed,name=statuses,proto3,enum=Enrollment_UserStatus" json:"statuses,omitempty"`
	GroupStatuses        []Group_GroupStatus     `protobuf:"varint,3,rep,packed,name=groupStatuses,proto3,enum=Group_GroupStatus" json:"groupStatuses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RecordRequest) Reset()         { *m = RecordRequest{} }
func (m *RecordRequest) String() string { return proto.CompactTextString(m) }
func (*RecordRequest) ProtoMessage()    {}
func (*RecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{17}
}
func (m *RecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordRequest.Merge(m, src)
}
func (m *RecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecordRequest proto.InternalMessageInfo

func (m *RecordRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RecordRequest) GetStatuses() []Enrollment_UserStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *RecordRequest) GetGroupStatuses() []Group_GroupStatus {
	if m != nil {
		return m.GroupStatuses
	}
	return nil
}

// fields can be empty, do not use fields for user validation, use context
// can be used in submission, enrollment and group requests, also in requests with multiple IDs
type ActionRequest struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	UserID               uint64                `protobuf:"varint,2,opt,name=userID,proto3" json:"userID,omitempty"`
	GroupID              uint64                `protobuf:"varint,3,opt,name=groupID,proto3" json:"groupID,omitempty"`
	CourseID             uint64                `protobuf:"varint,4,opt,name=courseID,proto3" json:"courseID,omitempty"`
	Status               Enrollment_UserStatus `protobuf:"varint,5,opt,name=status,proto3,enum=Enrollment_UserStatus" json:"status,omitempty"`
	GroupStatus          Group_GroupStatus     `protobuf:"varint,6,opt,name=groupStatus,proto3,enum=Group_GroupStatus" json:"groupStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ActionRequest) Reset()         { *m = ActionRequest{} }
func (m *ActionRequest) String() string { return proto.CompactTextString(m) }
func (*ActionRequest) ProtoMessage()    {}
func (*ActionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{18}
}
func (m *ActionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRequest.Merge(m, src)
}
func (m *ActionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRequest proto.InternalMessageInfo

func (m *ActionRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActionRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ActionRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *ActionRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

func (m *ActionRequest) GetStatus() Enrollment_UserStatus {
	if m != nil {
		return m.Status
	}
	return Enrollment_NONE
}

func (m *ActionRequest) GetGroupStatus() Group_GroupStatus {
	if m != nil {
		return m.GroupStatus
	}
	return Group_PENDING
}

type DirectoryRequest struct {
	Provider             string   `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	CourseID             uint64   `protobuf:"varint,2,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DirectoryRequest) Reset()         { *m = DirectoryRequest{} }
func (m *DirectoryRequest) String() string { return proto.CompactTextString(m) }
func (*DirectoryRequest) ProtoMessage()    {}
func (*DirectoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{19}
}
func (m *DirectoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectoryRequest.Merge(m, src)
}
func (m *DirectoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *DirectoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DirectoryRequest proto.InternalMessageInfo

func (m *DirectoryRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *DirectoryRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type RepositoryRequest struct {
	ID                   uint64          `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Type                 Repository_Type `protobuf:"varint,2,opt,name=type,proto3,enum=Repository_Type" json:"type,omitempty"`
	DirectoryID          uint64          `protobuf:"varint,3,opt,name=directoryID,proto3" json:"directoryID,omitempty"`
	RepositoryID         uint64          `protobuf:"varint,4,opt,name=repositoryID,proto3" json:"repositoryID,omitempty"`
	UserID               uint64          `protobuf:"varint,5,opt,name=userID,proto3" json:"userID,omitempty"`
	CourseID             uint64          `protobuf:"varint,6,opt,name=courseID,proto3" json:"courseID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RepositoryRequest) Reset()         { *m = RepositoryRequest{} }
func (m *RepositoryRequest) String() string { return proto.CompactTextString(m) }
func (*RepositoryRequest) ProtoMessage()    {}
func (*RepositoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{20}
}
func (m *RepositoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepositoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepositoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepositoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepositoryRequest.Merge(m, src)
}
func (m *RepositoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *RepositoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RepositoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RepositoryRequest proto.InternalMessageInfo

func (m *RepositoryRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RepositoryRequest) GetType() Repository_Type {
	if m != nil {
		return m.Type
	}
	return Repository_USER
}

func (m *RepositoryRequest) GetDirectoryID() uint64 {
	if m != nil {
		return m.DirectoryID
	}
	return 0
}

func (m *RepositoryRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *RepositoryRequest) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *RepositoryRequest) GetCourseID() uint64 {
	if m != nil {
		return m.CourseID
	}
	return 0
}

type Providers struct {
	Providers            []string `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Providers) Reset()         { *m = Providers{} }
func (m *Providers) String() string { return proto.CompactTextString(m) }
func (*Providers) ProtoMessage()    {}
func (*Providers) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{21}
}
func (m *Providers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Providers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Providers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Providers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Providers.Merge(m, src)
}
func (m *Providers) XXX_Size() int {
	return m.Size()
}
func (m *Providers) XXX_DiscardUnknown() {
	xxx_messageInfo_Providers.DiscardUnknown(m)
}

var xxx_messageInfo_Providers proto.InternalMessageInfo

func (m *Providers) GetProviders() []string {
	if m != nil {
		return m.Providers
	}
	return nil
}

type URLResponse struct {
	URL                  string   `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *URLResponse) Reset()         { *m = URLResponse{} }
func (m *URLResponse) String() string { return proto.CompactTextString(m) }
func (*URLResponse) ProtoMessage()    {}
func (*URLResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{22}
}
func (m *URLResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *URLResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLResponse.Merge(m, src)
}
func (m *URLResponse) XXX_Size() int {
	return m.Size()
}
func (m *URLResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_URLResponse.DiscardUnknown(m)
}

var xxx_messageInfo_URLResponse proto.InternalMessageInfo

func (m *URLResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{23}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("Group_GroupStatus", Group_GroupStatus_name, Group_GroupStatus_value)
	proto.RegisterEnum("Enrollment_UserStatus", Enrollment_UserStatus_name, Enrollment_UserStatus_value)
	proto.RegisterEnum("Repository_Type", Repository_Type_name, Repository_Type_value)
	proto.RegisterType((*User)(nil), "User")
	proto.RegisterType((*Users)(nil), "Users")
	proto.RegisterType((*RemoteIdentity)(nil), "RemoteIdentity")
	proto.RegisterType((*Group)(nil), "Group")
	proto.RegisterType((*Groups)(nil), "Groups")
	proto.RegisterType((*Course)(nil), "Course")
	proto.RegisterType((*Courses)(nil), "Courses")
	proto.RegisterType((*Enrollment)(nil), "Enrollment")
	proto.RegisterType((*Enrollments)(nil), "Enrollments")
	proto.RegisterType((*Assignment)(nil), "Assignment")
	proto.RegisterType((*Assignments)(nil), "Assignments")
	proto.RegisterType((*Submission)(nil), "Submission")
	proto.RegisterType((*Submissions)(nil), "Submissions")
	proto.RegisterType((*Repository)(nil), "Repository")
	proto.RegisterType((*Repositories)(nil), "Repositories")
	proto.RegisterType((*Directory)(nil), "Directory")
	proto.RegisterType((*Directories)(nil), "Directories")
	proto.RegisterType((*RecordRequest)(nil), "RecordRequest")
	proto.RegisterType((*ActionRequest)(nil), "ActionRequest")
	proto.RegisterType((*DirectoryRequest)(nil), "DirectoryRequest")
	proto.RegisterType((*RepositoryRequest)(nil), "RepositoryRequest")
	proto.RegisterType((*Providers)(nil), "Providers")
	proto.RegisterType((*URLResponse)(nil), "URLResponse")
	proto.RegisterType((*Void)(nil), "Void")
}

func init() { proto.RegisterFile("ag.proto", fileDescriptor_7a984e8f57169aa1) }

var fileDescriptor_7a984e8f57169aa1 = []byte{
	// 1811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x17, 0x25, 0x4a, 0xa2, 0x9e, 0x64, 0x87, 0x99, 0x2e, 0x52, 0xd6, 0x1b, 0xd8, 0xee, 0x34,
	0x28, 0xbc, 0x9b, 0x84, 0x29, 0xbc, 0x6d, 0xb0, 0xdd, 0x2d, 0x50, 0x28, 0x16, 0xab, 0x28, 0xeb,
	0x95, 0x8d, 0x91, 0xbc, 0x3d, 0x1a, 0xb4, 0x38, 0x91, 0xd9, 0x4a, 0xa2, 0x96, 0x43, 0x05, 0xeb,
	0x5b, 0x4f, 0xbd, 0xf5, 0xde, 0x5b, 0x4f, 0x3d, 0xf4, 0xef, 0xe8, 0xa5, 0xc7, 0x02, 0x3d, 0x16,
	0x08, 0x8a, 0xfc, 0x09, 0x39, 0xf6, 0x54, 0xcc, 0x07, 0xc9, 0x21, 0xe9, 0x8f, 0xa6, 0xbd, 0xd8,
	0xf3, 0xbe, 0x86, 0xef, 0xfd, 0xde, 0xc7, 0x3c, 0x81, 0xe5, 0xcf, 0xdd, 0x75, 0x1c, 0x25, 0xd1,
	0xce, 0xd3, 0x79, 0x98, 0x5c, 0x6e, 0x2e, 0xdc, 0x59, 0xb4, 0x7c, 0x36, 0x8f, 0xe6, 0xd1, 0x33,
	0xc1, 0xbe, 0xd8, 0xbc, 0x16, 0x94, 0x20, 0xc4, 0x49, 0xa9, 0xef, 0xcd, 0xa3, 0x68, 0xbe, 0xa0,
	0xb9, 0x56, 0x12, 0x2e, 0x29, 0x4b, 0xfc, 0xe5, 0x5a, 0x2a, 0xe0, 0x3f, 0xd6, 0xc1, 0x3c, 0x63,
	0x34, 0x46, 0xdb, 0x50, 0x1f, 0x0d, 0x1c, 0x63, 0xdf, 0x38, 0x30, 0x49, 0x7d, 0x34, 0x40, 0x0e,
	0xb4, 0x43, 0xd6, 0x0f, 0x96, 0xe1, 0xca, 0xa9, 0xef, 0x1b, 0x07, 0x16, 0x49, 0x49, 0x84, 0xc0,
	0x5c, 0xf9, 0x4b, 0xea, 0x34, 0xf6, 0x8d, 0x83, 0x0e, 0x11, 0x67, 0xf4, 0x10, 0x3a, 0x2c, 0xd9,
	0x04, 0x74, 0x95, 0x8c, 0x06, 0x8e, 0x29, 0x04, 0x39, 0x03, 0x7d, 0x04, 0x4d, 0xba, 0xf4, 0xc3,
	0x85, 0xd3, 0x14, 0x12, 0x49, 0x70, 0x1b, 0xff, 0x8d, 0x9f, 0xf8, 0xf1, 0x19, 0x39, 0x76, 0x5a,
	0xd2, 0x26, 0x63, 0x70, 0x9b, 0x45, 0x34, 0x0f, 0x57, 0x4e, 0x5b, 0xda, 0x08, 0x02, 0x7d, 0x09,
	0x76, 0x4c, 0x97, 0x51, 0x42, 0x47, 0xfc, 0xea, 0x30, 0x09, 0x29, 0x73, 0xac, 0xfd, 0xc6, 0x41,
	0xf7, 0xf0, 0x9e, 0x4b, 0x74, 0xc1, 0x15, 0xa9, 0x28, 0xa2, 0xa7, 0xd0, 0xa5, 0xab, 0x38, 0x5a,
	0x2c, 0x96, 0x74, 0x95, 0x30, 0xa7, 0x23, 0xec, 0xba, 0xae, 0x97, 0xf1, 0x88, 0x2e, 0xc7, 0x8f,
	0xa0, 0xc9, 0x91, 0x61, 0xe8, 0x63, 0x68, 0x6e, 0xf8, 0xc1, 0x31, 0x84, 0x45, 0xd3, 0xe5, 0x6c,
	0x22, 0x79, 0xf8, 0xbd, 0x01, 0xdb, 0xc5, 0x2f, 0x57, 0xa0, 0x7c, 0x05, 0xd6, 0x3a, 0x8e, 0xde,
	0x84, 0x01, 0x8d, 0x05, 0x96, 0x9d, 0x17, 0xee, 0xfb, 0xb7, 0x7b, 0x9f, 0xce, 0xa3, 0x78, 0xf9,
	0x05, 0xde, 0xac, 0xc2, 0x6f, 0x37, 0xf4, 0x3c, 0x5c, 0x05, 0xf4, 0xbb, 0x2f, 0x36, 0x61, 0x70,
	0x9e, 0xaa, 0x9e, 0x4b, 0xff, 0xcf, 0xc3, 0x00, 0x93, 0xcc, 0x9e, 0xdf, 0xa5, 0xe2, 0x1a, 0x88,
	0x04, 0x98, 0x1f, 0x7e, 0x57, 0x6a, 0x8f, 0xf6, 0xa1, 0xeb, 0xcf, 0x66, 0x94, 0xb1, 0x69, 0xf4,
	0x5b, 0xba, 0x52, 0x69, 0xd3, 0x59, 0xe8, 0x01, 0xb4, 0x78, 0x94, 0xa3, 0x81, 0xc8, 0x9c, 0x49,
	0x14, 0x85, 0xff, 0x5d, 0x87, 0xe6, 0x30, 0x8e, 0x36, 0xeb, 0x4a, 0xac, 0x7d, 0x55, 0x1c, 0x32,
	0xce, 0xa7, 0xef, 0xdf, 0xee, 0x7d, 0x72, 0x8d, 0x6f, 0x61, 0xf0, 0xdd, 0xb9, 0x62, 0xcc, 0xf9,
	0x35, 0xe7, 0xdc, 0x06, 0xab, 0x5a, 0x1a, 0x81, 0x35, 0x8b, 0x36, 0x31, 0xcb, 0x43, 0xfc, 0xc0,
	0x6b, 0x32, 0x73, 0xee, 0x7f, 0x42, 0xfd, 0xa5, 0xaa, 0x49, 0x93, 0x28, 0x0a, 0x7d, 0x0a, 0x2d,
	0x96, 0xf8, 0xc9, 0x86, 0x89, 0xb8, 0xb6, 0x0f, 0x91, 0x2b, 0xa2, 0x91, 0x7f, 0x27, 0x42, 0x42,
	0x94, 0x46, 0x9e, 0xfd, 0x56, 0x35, 0xfb, 0xe5, 0x92, 0x6a, 0xdf, 0x51, 0x52, 0x47, 0xd0, 0xd5,
	0x3e, 0x81, 0xba, 0xd0, 0x3e, 0xf5, 0xc6, 0x83, 0xd1, 0x78, 0x68, 0xd7, 0x50, 0x0f, 0x2c, 0xe2,
	0xbd, 0xf2, 0x8e, 0xa6, 0xde, 0xc0, 0x36, 0x38, 0xd5, 0x3f, 0x3d, 0x25, 0x27, 0xdf, 0x78, 0x03,
	0xbb, 0xce, 0x15, 0x07, 0xde, 0xb1, 0xc7, 0x45, 0x0d, 0x7c, 0x00, 0x2d, 0x71, 0x09, 0x43, 0xbb,
	0xd0, 0x12, 0x71, 0xa7, 0x95, 0xd9, 0x92, 0x01, 0x10, 0xc5, 0xc5, 0xbf, 0x6b, 0x40, 0xeb, 0x48,
	0x60, 0x51, 0xc9, 0xd3, 0x01, 0xdc, 0x93, 0x28, 0x1d, 0xc5, 0xd4, 0x4f, 0x22, 0x9e, 0xe2, 0xba,
	0x10, 0x96, 0xd9, 0xd7, 0xb6, 0x3b, 0x02, 0x73, 0x16, 0x05, 0x54, 0x95, 0x8c, 0x38, 0x73, 0xde,
	0x15, 0xf5, 0x63, 0x81, 0xe8, 0x16, 0x11, 0x67, 0x64, 0x43, 0x23, 0xf1, 0xe7, 0xaa, 0xb9, 0xf9,
	0x11, 0xed, 0x68, 0xbd, 0x20, 0x3b, 0x3b, 0xaf, 0xed, 0x7d, 0xe8, 0x06, 0x61, 0x4c, 0x67, 0x49,
	0x14, 0x5f, 0x8d, 0x06, 0x8e, 0x25, 0xfc, 0xd1, 0x59, 0xe8, 0x10, 0x2c, 0x09, 0x27, 0x0d, 0x9c,
	0x8e, 0xc8, 0xdc, 0x03, 0x0d, 0x6b, 0x91, 0x19, 0x95, 0xbd, 0x4c, 0xaf, 0x9c, 0x22, 0xb8, 0x3d,
	0x45, 0x5c, 0xdd, 0x67, 0x2c, 0x9c, 0xaf, 0xa4, 0x7a, 0x4f, 0xa9, 0xf7, 0x33, 0x1e, 0xd1, 0xe5,
	0x5a, 0x0a, 0xb6, 0xae, 0x4d, 0xc1, 0x13, 0x68, 0xcb, 0x0c, 0x30, 0xf4, 0x43, 0x68, 0x4b, 0x6c,
	0xd3, 0x74, 0xb5, 0x5d, 0x29, 0x22, 0x29, 0x1f, 0xff, 0xa9, 0x01, 0x90, 0x3b, 0x56, 0x49, 0x9a,
	0xde, 0x19, 0xf5, 0xff, 0xaf, 0x33, 0xbc, 0xac, 0xb3, 0xff, 0xa7, 0x16, 0x53, 0xc6, 0xfc, 0x95,
	0x10, 0xec, 0xac, 0xc3, 0x52, 0x12, 0xfd, 0x00, 0x4c, 0xae, 0x23, 0xca, 0x21, 0xeb, 0x1a, 0xc1,
	0x42, 0x7b, 0xd0, 0x92, 0x7e, 0x88, 0xc2, 0xd0, 0x70, 0x50, 0x6c, 0xf4, 0x10, 0x9a, 0xe2, 0x1a,
	0x51, 0x21, 0x39, 0xa6, 0x92, 0x89, 0xdc, 0xac, 0x79, 0xad, 0x5b, 0x4b, 0x40, 0x69, 0xe1, 0xaf,
	0x00, 0x72, 0x2e, 0xb2, 0xc0, 0x1c, 0x9f, 0x8c, 0x3d, 0xbb, 0xa6, 0x77, 0x9f, 0x51, 0xe8, 0x3e,
	0xd1, 0x6f, 0x93, 0xe9, 0xd9, 0xc0, 0x1b, 0x4f, 0xed, 0x06, 0x27, 0xa6, 0x5e, 0xff, 0xe8, 0xa5,
	0x47, 0x6c, 0x13, 0xff, 0x02, 0xba, 0x5e, 0xb1, 0x5a, 0xf4, 0xe2, 0x32, 0xee, 0xe8, 0xff, 0x3f,
	0xd7, 0x01, 0xf2, 0x4a, 0xaa, 0xe4, 0x77, 0xa7, 0x9c, 0x5f, 0x2d, 0x61, 0xd7, 0xb5, 0xe1, 0x0e,
	0x58, 0x0b, 0x7f, 0x35, 0xdf, 0xf8, 0xf3, 0xb4, 0x15, 0x33, 0x1a, 0x3d, 0x07, 0x2b, 0xa0, 0x7e,
	0xb0, 0x08, 0x57, 0x54, 0xe5, 0x60, 0xc7, 0x95, 0xcb, 0x80, 0x9b, 0x2e, 0x03, 0xee, 0x34, 0x5d,
	0x06, 0x48, 0xa6, 0x2b, 0x1e, 0x85, 0x4d, 0x12, 0xf5, 0xd7, 0xbc, 0x2d, 0x65, 0x86, 0x2c, 0xa2,
	0xb3, 0xf8, 0xcb, 0x1c, 0xc5, 0x69, 0xff, 0x6e, 0x11, 0x49, 0xa0, 0x5d, 0x80, 0x90, 0x89, 0x3c,
	0x1d, 0xfb, 0x17, 0x22, 0x33, 0x16, 0xd1, 0x38, 0xe8, 0x31, 0x00, 0xdb, 0x5c, 0x2c, 0x43, 0xc6,
	0xc2, 0x68, 0x25, 0x9a, 0x97, 0x03, 0x35, 0xc9, 0x58, 0x44, 0x13, 0x73, 0x94, 0xfb, 0x5a, 0x93,
	0x95, 0x7a, 0xd2, 0xb8, 0xbd, 0x27, 0xf1, 0xef, 0xeb, 0x00, 0xf9, 0xc5, 0x15, 0x94, 0x31, 0xf4,
	0x72, 0xed, 0x0c, 0xe9, 0x02, 0x4f, 0x7b, 0xf8, 0x1a, 0xfa, 0xc3, 0x77, 0x4b, 0xbd, 0x7f, 0x04,
	0x4d, 0x36, 0x8b, 0x62, 0xaa, 0xe6, 0x9f, 0x24, 0xf8, 0xb7, 0xc4, 0xe1, 0xe4, 0xe2, 0x37, 0x74,
	0x96, 0x30, 0x35, 0x09, 0x0b, 0x3c, 0xbe, 0x07, 0x5d, 0x6c, 0xc2, 0x45, 0x30, 0x5a, 0xbd, 0x8e,
	0xd4, 0x4c, 0xcc, 0x19, 0x1c, 0xd7, 0x59, 0xb4, 0x5c, 0x86, 0xc9, 0x4b, 0x9f, 0x5d, 0x0a, 0x5c,
	0x3b, 0x44, 0xe3, 0xf0, 0x1a, 0xf0, 0x65, 0x62, 0xe4, 0x48, 0xb4, 0x48, 0x46, 0x73, 0x18, 0x73,
	0x1c, 0x04, 0x8c, 0x39, 0xc6, 0x39, 0x8c, 0x5a, 0x0e, 0x74, 0x39, 0xfe, 0x4b, 0x1d, 0x80, 0xd0,
	0x75, 0xc4, 0x42, 0x3e, 0x7d, 0x2b, 0x30, 0x96, 0xa6, 0x75, 0xbd, 0x3a, 0xad, 0x31, 0xf4, 0xe2,
	0xcc, 0x3e, 0x83, 0xb2, 0xc0, 0xd3, 0x80, 0x36, 0x6f, 0x02, 0xba, 0x59, 0x04, 0xda, 0x81, 0xf6,
	0xcb, 0xe9, 0xd7, 0xc7, 0xf9, 0xd2, 0x98, 0x92, 0xe8, 0x09, 0xdf, 0x8d, 0xd6, 0xd1, 0xf4, 0x6a,
	0x4d, 0x05, 0x8e, 0xdb, 0x87, 0xb6, 0x9b, 0x07, 0xe0, 0x72, 0x3e, 0xc9, 0x34, 0xf0, 0x57, 0x60,
	0xf2, 0xff, 0x7c, 0x20, 0x9c, 0x4d, 0x3c, 0x62, 0xd7, 0xd0, 0x3d, 0xe8, 0xf6, 0x27, 0x93, 0xd1,
	0x70, 0xfc, 0xb5, 0x37, 0x9e, 0x4e, 0x6c, 0x03, 0x75, 0xa0, 0x39, 0xf5, 0x26, 0xd3, 0x89, 0x5d,
	0x47, 0x5b, 0xd0, 0x99, 0x9c, 0x1c, 0x9f, 0x4d, 0x47, 0x27, 0xe3, 0x89, 0xdd, 0x40, 0xdb, 0x00,
	0x47, 0x27, 0x67, 0x64, 0xe2, 0x8d, 0xc6, 0xbf, 0x3a, 0xb1, 0x4d, 0xfc, 0x4b, 0xe8, 0x65, 0x5f,
	0xe2, 0xab, 0xe6, 0x33, 0x2d, 0xf4, 0x90, 0xe6, 0x58, 0xe7, 0xee, 0x90, 0x82, 0x02, 0x1e, 0x42,
	0x67, 0x90, 0x42, 0x57, 0x81, 0x1a, 0x81, 0xb9, 0xf6, 0x93, 0x4b, 0xb9, 0x54, 0x11, 0x71, 0xe6,
	0xc0, 0xc9, 0x65, 0x59, 0x4d, 0x04, 0x45, 0xe1, 0x2f, 0xa1, 0x9b, 0x5e, 0xc4, 0x1d, 0x79, 0x92,
	0x67, 0x29, 0xf7, 0x03, 0xdc, 0xec, 0x5b, 0x44, 0x17, 0xe3, 0x3f, 0x18, 0xb0, 0x45, 0xe8, 0x2c,
	0x8a, 0x03, 0x42, 0xbf, 0xdd, 0x50, 0x56, 0x1d, 0x51, 0x87, 0x60, 0xc9, 0xb1, 0x4a, 0x99, 0x53,
	0xdf, 0x6f, 0xdc, 0xf6, 0x02, 0xa7, 0x7a, 0xe8, 0x73, 0xd8, 0x9a, 0xe7, 0x5b, 0x0f, 0x65, 0x4e,
	0x43, 0x18, 0x5e, 0xb7, 0x74, 0x15, 0x15, 0xf1, 0x3f, 0x0c, 0xd8, 0xea, 0xcf, 0x12, 0x5e, 0x9a,
	0x37, 0xf8, 0x93, 0xd7, 0x4f, 0xfd, 0xa6, 0xfa, 0x69, 0x14, 0xeb, 0x47, 0x1f, 0xb2, 0x66, 0x69,
	0xc8, 0xba, 0xa5, 0xbd, 0xf0, 0x8e, 0xa7, 0x05, 0xfd, 0x14, 0xba, 0x9a, 0xc3, 0xa2, 0x1e, 0xaf,
	0x8f, 0x4b, 0x57, 0xc3, 0xaf, 0xc0, 0xce, 0xf1, 0x57, 0x71, 0xe9, 0x7b, 0x91, 0x51, 0xda, 0x8b,
	0x6e, 0x79, 0x16, 0xf0, 0x5f, 0x0d, 0xb8, 0xaf, 0x15, 0xd5, 0x0d, 0x28, 0x3d, 0x02, 0x33, 0xe1,
	0x5d, 0x51, 0xbf, 0xa1, 0x2b, 0x84, 0xb4, 0xdc, 0xd1, 0x8d, 0xbb, 0x3b, 0xda, 0xbc, 0xb5, 0xa3,
	0x0b, 0xbf, 0x19, 0x0a, 0x51, 0xb4, 0x4a, 0x51, 0x7c, 0x02, 0x9d, 0x53, 0x15, 0xad, 0x98, 0x87,
	0x69, 0xe8, 0xb2, 0x60, 0x3b, 0x24, 0x67, 0xe0, 0x3d, 0xe8, 0x9e, 0x91, 0x63, 0x42, 0xd9, 0x3a,
	0x5a, 0x31, 0xca, 0x37, 0x4c, 0x3e, 0x09, 0x24, 0x64, 0xfc, 0x88, 0x5b, 0x60, 0x7e, 0x13, 0x85,
	0xc1, 0xe1, 0x3f, 0x3b, 0x70, 0xbf, 0xbf, 0x49, 0xa2, 0x79, 0xec, 0x07, 0x34, 0x9e, 0xd0, 0xf8,
	0x4d, 0x38, 0xe3, 0x03, 0xb9, 0x3d, 0xa4, 0x89, 0xfc, 0xc5, 0xeb, 0x16, 0x4a, 0x7d, 0x47, 0xee,
	0x28, 0xb8, 0x86, 0x3e, 0x06, 0x4b, 0xe9, 0x30, 0xd4, 0x74, 0xf9, 0x65, 0x3b, 0x2d, 0x21, 0x63,
	0xb8, 0x86, 0x1e, 0x02, 0x9c, 0xad, 0x03, 0x3f, 0xa1, 0xe2, 0x0e, 0x69, 0x93, 0x9b, 0x3e, 0x12,
	0xa6, 0xea, 0xa7, 0x51, 0xe9, 0x7e, 0xb5, 0xc6, 0xe0, 0x1a, 0xfa, 0x0c, 0xbe, 0x9f, 0x6a, 0xbd,
	0xb8, 0xe2, 0x96, 0xfd, 0x55, 0x90, 0xee, 0xe9, 0x6e, 0xa1, 0xde, 0x35, 0xa3, 0x1f, 0x43, 0x27,
	0x35, 0x62, 0x95, 0xbb, 0xdb, 0x52, 0x8d, 0x3b, 0xb8, 0x07, 0x5d, 0xb1, 0xbc, 0x53, 0xe9, 0x85,
	0xba, 0x40, 0xbb, 0x68, 0x17, 0xba, 0x32, 0x82, 0xa2, 0x82, 0x8c, 0x54, 0xca, 0x07, 0x74, 0x41,
	0x6f, 0x94, 0x4b, 0x47, 0x32, 0x7f, 0xcb, 0x8e, 0x48, 0x81, 0x70, 0x04, 0x32, 0xbd, 0x0c, 0x48,
	0x4b, 0xc9, 0xb9, 0xa7, 0xcf, 0xc1, 0xc9, 0x15, 0x7e, 0x1d, 0x26, 0x97, 0xfa, 0xea, 0x5b, 0xba,
	0x57, 0xb7, 0xfb, 0xb9, 0x80, 0x4f, 0xd2, 0xfc, 0x8d, 0x8c, 0x97, 0x3e, 0x87, 0x8c, 0x3f, 0x01,
	0x65, 0xb3, 0x9e, 0xab, 0x15, 0x0b, 0xae, 0xf1, 0x02, 0x96, 0xe0, 0x28, 0xf7, 0x53, 0x77, 0x75,
	0xbf, 0xf7, 0xa1, 0x27, 0xf1, 0x29, 0xeb, 0x64, 0x08, 0x3c, 0xe3, 0x53, 0xf2, 0x75, 0x4c, 0xd9,
	0xe5, 0x0d, 0x28, 0xf4, 0xb4, 0xdd, 0x84, 0x7b, 0xfc, 0x39, 0x3c, 0x18, 0xd2, 0x44, 0x5b, 0x1c,
	0x5f, 0x5c, 0xdd, 0x68, 0xa9, 0x69, 0xe1, 0x1a, 0x7a, 0x0c, 0xb6, 0x74, 0xb8, 0x80, 0x4d, 0xb1,
	0x46, 0x32, 0xbf, 0x1e, 0x83, 0x2d, 0x3d, 0xff, 0x6f, 0x94, 0x7f, 0x02, 0xdb, 0x43, 0x9a, 0xe8,
	0xfb, 0x41, 0x59, 0xb5, 0xa7, 0xad, 0x06, 0xdc, 0x17, 0x17, 0xb6, 0x0a, 0x16, 0x15, 0xe7, 0xf5,
	0x5d, 0x02, 0xd7, 0xd0, 0xcf, 0xe0, 0x7b, 0x69, 0xc5, 0x7e, 0xc8, 0x67, 0xb2, 0x28, 0x6e, 0xf9,
	0x52, 0x29, 0x0a, 0x7d, 0x59, 0xbc, 0x2b, 0x17, 0xcf, 0xc1, 0x1e, 0xd2, 0x24, 0x9f, 0x80, 0xbc,
	0x6c, 0x90, 0x5b, 0x99, 0xa1, 0x95, 0xd2, 0xf9, 0x11, 0xf4, 0x86, 0x34, 0xc9, 0xc7, 0x94, 0x2a,
	0x68, 0x70, 0x33, 0x96, 0xe8, 0x6c, 0xee, 0x8e, 0xfe, 0x00, 0xdf, 0x77, 0xcb, 0xb3, 0x7e, 0xa7,
	0xe7, 0x6a, 0x0a, 0xb8, 0x86, 0x0e, 0x05, 0xae, 0xda, 0xaa, 0x75, 0x9d, 0x3b, 0xfa, 0xee, 0x80,
	0x6b, 0x2f, 0x7a, 0x7f, 0x7b, 0xb7, 0x6b, 0xfc, 0xfd, 0xdd, 0xae, 0xf1, 0xaf, 0x77, 0xbb, 0xc6,
	0x45, 0x4b, 0xac, 0xf4, 0x9f, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff, 0x2a, 0xaa, 0x69, 0x5b, 0x28,
	0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AutograderServiceClient is the client API for AutograderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutograderServiceClient interface {
	GetUser(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*User, error)
	GetUsers(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Users, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	GetGroup(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Group, error)
	GetGroupByUserAndCourse(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Group, error)
	GetGroups(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Groups, error)
	CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error)
	UpdateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error)
	DeleteGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error)
	GetCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Course, error)
	GetCourses(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Courses, error)
	GetCoursesWithEnrollment(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Courses, error)
	GetCourseInformationURL(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*URLResponse, error)
	CreateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Course, error)
	UpdateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Void, error)
	RefreshCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Assignments, error)
	GetEnrollmentsByCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Enrollments, error)
	CreateEnrollment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Void, error)
	UpdateEnrollment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Void, error)
	GetSubmissions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Submissions, error)
	GetSubmission(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Submission, error)
	GetGroupSubmissions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Submissions, error)
	UpdateSubmission(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Void, error)
	GetAssignments(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Assignments, error)
	GetRepositoryURL(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*URLResponse, error)
	GetProviders(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Providers, error)
	GetDirectories(ctx context.Context, in *DirectoryRequest, opts ...grpc.CallOption) (*Directories, error)
	// The sole purpose of this RPC is to provide a reference to Repository type to TypeScript client
	// Might later be used as a more general type for retrieval of repo information
	GetRepository(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*Repository, error)
}

type autograderServiceClient struct {
	cc *grpc.ClientConn
}

func NewAutograderServiceClient(cc *grpc.ClientConn) AutograderServiceClient {
	return &autograderServiceClient{cc}
}

func (c *autograderServiceClient) GetUser(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/AutograderService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetUsers(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Users, error) {
	out := new(Users)
	err := c.cc.Invoke(ctx, "/AutograderService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroup(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroupByUserAndCourse(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroupByUserAndCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroups(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Groups, error) {
	out := new(Groups)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) DeleteGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/DeleteGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Course, error) {
	out := new(Course)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourses(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Courses, error) {
	out := new(Courses)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCoursesWithEnrollment(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Courses, error) {
	out := new(Courses)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCoursesWithEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetCourseInformationURL(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*URLResponse, error) {
	out := new(URLResponse)
	err := c.cc.Invoke(ctx, "/AutograderService/GetCourseInformationURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Course, error) {
	out := new(Course)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateCourse(ctx context.Context, in *Course, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) RefreshCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Assignments, error) {
	out := new(Assignments)
	err := c.cc.Invoke(ctx, "/AutograderService/RefreshCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetEnrollmentsByCourse(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Enrollments, error) {
	out := new(Enrollments)
	err := c.cc.Invoke(ctx, "/AutograderService/GetEnrollmentsByCourse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) CreateEnrollment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/CreateEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateEnrollment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetSubmissions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Submissions, error) {
	out := new(Submissions)
	err := c.cc.Invoke(ctx, "/AutograderService/GetSubmissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetSubmission(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Submission, error) {
	out := new(Submission)
	err := c.cc.Invoke(ctx, "/AutograderService/GetSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetGroupSubmissions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*Submissions, error) {
	out := new(Submissions)
	err := c.cc.Invoke(ctx, "/AutograderService/GetGroupSubmissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) UpdateSubmission(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/AutograderService/UpdateSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetAssignments(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*Assignments, error) {
	out := new(Assignments)
	err := c.cc.Invoke(ctx, "/AutograderService/GetAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetRepositoryURL(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*URLResponse, error) {
	out := new(URLResponse)
	err := c.cc.Invoke(ctx, "/AutograderService/GetRepositoryURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetProviders(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Providers, error) {
	out := new(Providers)
	err := c.cc.Invoke(ctx, "/AutograderService/GetProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetDirectories(ctx context.Context, in *DirectoryRequest, opts ...grpc.CallOption) (*Directories, error) {
	out := new(Directories)
	err := c.cc.Invoke(ctx, "/AutograderService/GetDirectories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autograderServiceClient) GetRepository(ctx context.Context, in *RepositoryRequest, opts ...grpc.CallOption) (*Repository, error) {
	out := new(Repository)
	err := c.cc.Invoke(ctx, "/AutograderService/GetRepository", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutograderServiceServer is the server API for AutograderService service.
type AutograderServiceServer interface {
	GetUser(context.Context, *RecordRequest) (*User, error)
	GetUsers(context.Context, *Void) (*Users, error)
	UpdateUser(context.Context, *User) (*User, error)
	GetGroup(context.Context, *RecordRequest) (*Group, error)
	GetGroupByUserAndCourse(context.Context, *ActionRequest) (*Group, error)
	GetGroups(context.Context, *RecordRequest) (*Groups, error)
	CreateGroup(context.Context, *Group) (*Group, error)
	UpdateGroup(context.Context, *Group) (*Void, error)
	DeleteGroup(context.Context, *Group) (*Void, error)
	GetCourse(context.Context, *RecordRequest) (*Course, error)
	GetCourses(context.Context, *Void) (*Courses, error)
	GetCoursesWithEnrollment(context.Context, *RecordRequest) (*Courses, error)
	GetCourseInformationURL(context.Context, *RecordRequest) (*URLResponse, error)
	CreateCourse(context.Context, *Course) (*Course, error)
	UpdateCourse(context.Context, *Course) (*Void, error)
	RefreshCourse(context.Context, *RecordRequest) (*Assignments, error)
	GetEnrollmentsByCourse(context.Context, *RecordRequest) (*Enrollments, error)
	CreateEnrollment(context.Context, *ActionRequest) (*Void, error)
	UpdateEnrollment(context.Context, *ActionRequest) (*Void, error)
	GetSubmissions(context.Context, *ActionRequest) (*Submissions, error)
	GetSubmission(context.Context, *RecordRequest) (*Submission, error)
	GetGroupSubmissions(context.Context, *ActionRequest) (*Submissions, error)
	UpdateSubmission(context.Context, *RecordRequest) (*Void, error)
	GetAssignments(context.Context, *RecordRequest) (*Assignments, error)
	GetRepositoryURL(context.Context, *RepositoryRequest) (*URLResponse, error)
	GetProviders(context.Context, *Void) (*Providers, error)
	GetDirectories(context.Context, *DirectoryRequest) (*Directories, error)
	// The sole purpose of this RPC is to provide a reference to Repository type to TypeScript client
	// Might later be used as a more general type for retrieval of repo information
	GetRepository(context.Context, *RepositoryRequest) (*Repository, error)
}

func RegisterAutograderServiceServer(s *grpc.Server, srv AutograderServiceServer) {
	s.RegisterService(&_AutograderService_serviceDesc, srv)
}

func _AutograderService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetUser(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetUsers(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroup(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroupByUserAndCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroupByUserAndCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroupByUserAndCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroupByUserAndCourse(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroups(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).DeleteGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourse(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourses(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCoursesWithEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCoursesWithEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCoursesWithEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCoursesWithEnrollment(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetCourseInformationURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetCourseInformationURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetCourseInformationURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetCourseInformationURL(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Course)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateCourse(ctx, req.(*Course))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Course)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateCourse(ctx, req.(*Course))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_RefreshCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).RefreshCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/RefreshCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).RefreshCourse(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetEnrollmentsByCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetEnrollmentsByCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetEnrollmentsByCourse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetEnrollmentsByCourse(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_CreateEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).CreateEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/CreateEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).CreateEnrollment(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateEnrollment(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetSubmissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetSubmissions(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetSubmission(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetGroupSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetGroupSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetGroupSubmissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetGroupSubmissions(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_UpdateSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).UpdateSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/UpdateSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).UpdateSubmission(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetAssignments(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetRepositoryURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetRepositoryURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetRepositoryURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetRepositoryURL(ctx, req.(*RepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetProviders(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetDirectories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetDirectories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetDirectories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetDirectories(ctx, req.(*DirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutograderService_GetRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutograderServiceServer).GetRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AutograderService/GetRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutograderServiceServer).GetRepository(ctx, req.(*RepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutograderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "AutograderService",
	HandlerType: (*AutograderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _AutograderService_GetUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _AutograderService_GetUsers_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _AutograderService_UpdateUser_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _AutograderService_GetGroup_Handler,
		},
		{
			MethodName: "GetGroupByUserAndCourse",
			Handler:    _AutograderService_GetGroupByUserAndCourse_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _AutograderService_GetGroups_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _AutograderService_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _AutograderService_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _AutograderService_DeleteGroup_Handler,
		},
		{
			MethodName: "GetCourse",
			Handler:    _AutograderService_GetCourse_Handler,
		},
		{
			MethodName: "GetCourses",
			Handler:    _AutograderService_GetCourses_Handler,
		},
		{
			MethodName: "GetCoursesWithEnrollment",
			Handler:    _AutograderService_GetCoursesWithEnrollment_Handler,
		},
		{
			MethodName: "GetCourseInformationURL",
			Handler:    _AutograderService_GetCourseInformationURL_Handler,
		},
		{
			MethodName: "CreateCourse",
			Handler:    _AutograderService_CreateCourse_Handler,
		},
		{
			MethodName: "UpdateCourse",
			Handler:    _AutograderService_UpdateCourse_Handler,
		},
		{
			MethodName: "RefreshCourse",
			Handler:    _AutograderService_RefreshCourse_Handler,
		},
		{
			MethodName: "GetEnrollmentsByCourse",
			Handler:    _AutograderService_GetEnrollmentsByCourse_Handler,
		},
		{
			MethodName: "CreateEnrollment",
			Handler:    _AutograderService_CreateEnrollment_Handler,
		},
		{
			MethodName: "UpdateEnrollment",
			Handler:    _AutograderService_UpdateEnrollment_Handler,
		},
		{
			MethodName: "GetSubmissions",
			Handler:    _AutograderService_GetSubmissions_Handler,
		},
		{
			MethodName: "GetSubmission",
			Handler:    _AutograderService_GetSubmission_Handler,
		},
		{
			MethodName: "GetGroupSubmissions",
			Handler:    _AutograderService_GetGroupSubmissions_Handler,
		},
		{
			MethodName: "UpdateSubmission",
			Handler:    _AutograderService_UpdateSubmission_Handler,
		},
		{
			MethodName: "GetAssignments",
			Handler:    _AutograderService_GetAssignments_Handler,
		},
		{
			MethodName: "GetRepositoryURL",
			Handler:    _AutograderService_GetRepositoryURL_Handler,
		},
		{
			MethodName: "GetProviders",
			Handler:    _AutograderService_GetProviders_Handler,
		},
		{
			MethodName: "GetDirectories",
			Handler:    _AutograderService_GetDirectories_Handler,
		},
		{
			MethodName: "GetRepository",
			Handler:    _AutograderService_GetRepository_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ag.proto",
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.IsAdmin {
		dAtA[i] = 0x10
		i++
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.StudentID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.StudentID)))
		i += copy(dAtA[i:], m.StudentID)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.AvatarURL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AvatarURL)))
		i += copy(dAtA[i:], m.AvatarURL)
	}
	if len(m.Login) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Login)))
		i += copy(dAtA[i:], m.Login)
	}
	if len(m.RemoteIdentities) > 0 {
		for _, msg := range m.RemoteIdentities {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Users) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Users) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIdentity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.RemoteID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RemoteID))
	}
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if m.UserID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.TeamID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.TeamID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Groups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Groups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Course) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Course) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseCreatorID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseCreatorID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Year != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Year))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.DirectoryID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.DirectoryID))
	}
	if m.Enrolled != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x52
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0x62
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Courses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Courses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, msg := range m.Courses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Enrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Course != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course.Size()))
		n2, err := m.Course.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Group != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group.Size()))
		n3, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Enrollments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Assignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Deadline != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Deadline.Size()))
		n4, err := m.Deadline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.AutoApprove {
		dAtA[i] = 0x30
		i++
		if m.AutoApprove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Order != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Order))
	}
	if m.IsGroupLab {
		dAtA[i] = 0x40
		i++
		if m.IsGroupLab {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Submission != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Submission.Size()))
		n5, err := m.Submission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Assignments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Submission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.AssignmentID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.AssignmentID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Score))
	}
	if len(m.ScoreObjects) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.ScoreObjects)))
		i += copy(dAtA[i:], m.ScoreObjects)
	}
	if len(m.BuildInfo) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.BuildInfo)))
		i += copy(dAtA[i:], m.BuildInfo)
	}
	if len(m.CommitHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.CommitHash)))
		i += copy(dAtA[i:], m.CommitHash)
	}
	if m.Approved {
		dAtA[i] = 0x48
		i++
		if m.Approved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Submissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, msg := range m.Submissions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Repository) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repository) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.DirectoryID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.DirectoryID))
	}
	if m.RepositoryID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if len(m.HTMLURL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.HTMLURL)))
		i += copy(dAtA[i:], m.HTMLURL)
	}
	if m.RepoType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepoType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Repositories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repositories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repositories) > 0 {
		for _, msg := range m.Repositories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Directory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Directory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Directories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Directories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Directories) > 0 {
		for _, msg := range m.Directories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Statuses) > 0 {
		dAtA7 := make([]byte, len(m.Statuses)*10)
		var j6 int
		for _, num := range m.Statuses {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.GroupStatuses) > 0 {
		dAtA9 := make([]byte, len(m.GroupStatuses)*10)
		var j8 int
		for _, num := range m.GroupStatuses {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if m.GroupStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupStatus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DirectoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepositoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepositoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Type))
	}
	if m.DirectoryID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.DirectoryID))
	}
	if m.RepositoryID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.UserID))
	}
	if m.CourseID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Providers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Providers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *URLResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAg(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.IsAdmin {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.StudentID)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if len(m.RemoteIdentities) > 0 {
		for _, e := range m.RemoteIdentities {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Users) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.RemoteID != 0 {
		n += 1 + sovAg(uint64(m.RemoteID))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.TeamID != 0 {
		n += 1 + sovAg(uint64(m.TeamID))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Groups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Course) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseCreatorID != 0 {
		n += 1 + sovAg(uint64(m.CourseCreatorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Year != 0 {
		n += 1 + sovAg(uint64(m.Year))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.DirectoryID != 0 {
		n += 1 + sovAg(uint64(m.DirectoryID))
	}
	if m.Enrolled != 0 {
		n += 1 + sovAg(uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Courses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, e := range m.Courses {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Enrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Course != nil {
		l = m.Course.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Enrollments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Assignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Deadline != nil {
		l = m.Deadline.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.AutoApprove {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovAg(uint64(m.Order))
	}
	if m.IsGroupLab {
		n += 2
	}
	if m.Submission != nil {
		l = m.Submission.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Assignments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Submission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.AssignmentID != 0 {
		n += 1 + sovAg(uint64(m.AssignmentID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.Score != 0 {
		n += 1 + sovAg(uint64(m.Score))
	}
	l = len(m.ScoreObjects)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.BuildInfo)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.CommitHash)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Approved {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Submissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, e := range m.Submissions {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Repository) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.DirectoryID != 0 {
		n += 1 + sovAg(uint64(m.DirectoryID))
	}
	if m.RepositoryID != 0 {
		n += 1 + sovAg(uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	l = len(m.HTMLURL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.RepoType != 0 {
		n += 1 + sovAg(uint64(m.RepoType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Repositories) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Repositories) > 0 {
		for _, e := range m.Repositories {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Directory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Directories) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Directories) > 0 {
		for _, e := range m.Directories {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if len(m.Statuses) > 0 {
		l = 0
		for _, e := range m.Statuses {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if len(m.GroupStatuses) > 0 {
		l = 0
		for _, e := range m.GroupStatuses {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.GroupID != 0 {
		n += 1 + sovAg(uint64(m.GroupID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if m.GroupStatus != 0 {
		n += 1 + sovAg(uint64(m.GroupStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirectoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepositoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovAg(uint64(m.Type))
	}
	if m.DirectoryID != 0 {
		n += 1 + sovAg(uint64(m.DirectoryID))
	}
	if m.RepositoryID != 0 {
		n += 1 + sovAg(uint64(m.RepositoryID))
	}
	if m.UserID != 0 {
		n += 1 + sovAg(uint64(m.UserID))
	}
	if m.CourseID != 0 {
		n += 1 + sovAg(uint64(m.CourseID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Providers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			l = len(s)
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *URLResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAg(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAg(x uint64) (n int) {
	return sovAg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIdentities = append(m.RemoteIdentities, &RemoteIdentity{})
			if err := m.RemoteIdentities[len(m.RemoteIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Users) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Users: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Users: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteID", wireType)
			}
			m.RemoteID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Group_GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Groups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Groups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Groups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Course) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Course: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Course: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseCreatorID", wireType)
			}
			m.CourseCreatorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseCreatorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Year |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryID", wireType)
			}
			m.DirectoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrolled", wireType)
			}
			m.Enrolled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enrolled |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Courses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Courses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Courses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Courses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Courses = append(m.Courses, &Course{})
			if err := m.Courses[len(m.Courses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Course == nil {
				m.Course = &Course{}
			}
			if err := m.Course.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadline == nil {
				m.Deadline = &types.Timestamp{}
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApprove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApprove = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGroupLab", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGroupLab = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Submission == nil {
				m.Submission = &Submission{}
			}
			if err := m.Submission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignmentID", wireType)
			}
			m.AssignmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreObjects", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScoreObjects = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submissions = append(m.Submissions, &Submission{})
			if err := m.Submissions[len(m.Submissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repository) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repository: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repository: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryID", wireType)
			}
			m.DirectoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepositoryID", wireType)
			}
			m.RepositoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepositoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTMLURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTMLURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoType", wireType)
			}
			m.RepoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepoType |= Repository_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repositories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repositories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repositories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repositories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repositories = append(m.Repositories, &Repository{})
			if err := m.Repositories[len(m.Repositories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Directory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Directory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Directory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Directories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Directories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Directories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Directories = append(m.Directories, &Directory{})
			if err := m.Directories[len(m.Directories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Enrollment_UserStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Enrollment_UserStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Statuses = append(m.Statuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Statuses) == 0 {
					m.Statuses = make([]Enrollment_UserStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Enrollment_UserStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Enrollment_UserStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Statuses = append(m.Statuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
		case 3:
			if wireType == 0 {
				var v Group_GroupStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Group_GroupStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupStatuses = append(m.GroupStatuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupStatuses) == 0 {
					m.GroupStatuses = make([]Group_GroupStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Group_GroupStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Group_GroupStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupStatuses = append(m.GroupStatuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupStatuses", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupStatus", wireType)
			}
			m.GroupStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupStatus |= Group_GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepositoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepositoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepositoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Repository_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryID", wireType)
			}
			m.DirectoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepositoryID", wireType)
			}
			m.RepositoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepositoryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseID", wireType)
			}
			m.CourseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Providers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Providers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Providers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAg
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAg
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAg
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAg(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAg
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAg = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAg   = fmt.Errorf("proto: integer overflow")
)
